{"title":"Aotu.io","description":"凹凸实验室(Aotu.io) 始建于2015年，是一个年轻基情的技术社区组织。<br/>O2面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。","language":"zh-cn","link":"https://aotu.io","pubDate":"Thu, 29 Jun 2017 04:00:00 GMT","lastBuildDate":"Mon, 03 Jul 2017 09:11:16 GMT","generator":"hexo-generator-json-feed","webMaster":"凹凸实验室","items":[{"title":"用Web技术实现移动监测","link":"https://aotu.io/notes/2017/06/29/motion-detection/","description":"本文将阐述如何通过 Web 技术实现简易的运动监测效果，并附上一些有意思的案例。 移动侦测，英文翻译为“Motion detection technology”，一般也叫运动检测，常用于无人值守监控录像和自动报警。通过摄像头按照不同帧率采集得到的图像会被 CPU 按照一定算法进行计算和比较，当画面有变化时，如有人走过，镜头被移动，计算比较结果得出的数字会超过阈值并指示系统能自动作出相应的处理。——百度百科 由上述引用语句可得出“移动监测”需要以下要素： 一个拥有美拍功能的“摄像头”（啪啪啪） 用于判断移动的算法（这部分交给我） 移动后的处理（你说了算） 注：本文涉及的所有案例均基于 PC/Mac 较新版本的 Chrome / Firefox 浏览器。 对方不想和你说话，并向你扔来一个链接： 体验链接&gt;&gt; 该案例有以下两个功能： 拍好 POST 后的 1 秒会进行拍照 静止 1 秒后音乐会停止，产生移动会恢复播放状态 上述案例也许并不能直接体现出『移动监测』的实际效果和原理，下面再看看这个案例。 体验链接&gt;&gt; 案例的左侧是视频源，而右侧则是移动后的像素处理（像素化、判断移动和只保留绿色等）。 因为是基于 Web 技术，所以视频源采用 WebRTC，像素处理则采用 Canvas。 视频源不依赖 Flash 或 Silverlight，我们使用 WebRTC (Web Real-Time Communications) 中的 navigator.getUserMedia() API，该 API 允许 Web 应用获取用户的摄像头与麦克风流（stream）。 示例代码如下：1234567891011121314151617181920&lt;!-- 若不加 autoplay，则会停留在第一帧 --&gt;&lt;video id=\"video\" autoplay&gt;&lt;/video&gt;// 具体参数含义可看相关文档。const constraints = &#123; audio: false, video: &#123; width: 640, height: 480 &#125;&#125;navigator.mediaDevices.getUserMedia(constraints) .then(stream =&gt; &#123; // 将视频源展示在 video 中 video.srcObject = stream &#125;) .catch(err =&gt; &#123; console.log(err) &#125;) 对于兼容性问题，Safari 11 开始支持 WebRTC 了。具体可查看 caniuse。 像素处理在得到视频源后，我们就有了判断物体是否移动的素材。当然，这里并没有采用什么高深的识别算法，只是利用连续两帧截图的像素差异来判断物体是否发生移动（严格来说，是画面的变化）。 截图获取视频源截图的示例代码：123456789101112const video = document.getElementById('video')const canvas = document.createElement('canvas')const ctx = canvas.getContext('2d')canvas.width = 640canvas.height = 480// 获取视频中的一帧function capture () &#123; ctx.drawImage(video, 0, 0, canvas.width, canvas.height) // ...其它操作&#125; 得出截图间的差异对于两张图的像素差异，在 凹凸实验室 的 《“等一下，我碰！”——常见的2D碰撞检测》 这篇博文中所提及的“像素检测”碰撞算法是解决办法之一。该算法是通过遍历两个离屏画布（offscreen canvas）同一位置的像素点的透明度是否同时大于 0，来判断碰撞与否。当然，这里要改为『同一位置的像素点是否不同（或差异小于某阈值）』来判断移动与否。 但上述方式稍显麻烦和低效，这里我们采用 ctx.globalCompositeOperation = &#39;difference&#39; 指定画布新增元素（即第二张截图与第一张截图）的合成方式，得出两张截图的差异部分。 体验链接&gt;&gt; 示例代码：1234567891011function diffTwoImage () &#123; // 设置新增元素的合成方式 ctx.globalCompositeOperation = 'difference' // 清除画布 ctx.clearRect(0, 0, canvas.width, canvas.height) // 假设两张图像尺寸相等 ctx.drawImage(firstImg, 0, 0) ctx.drawImage(secondImg, 0, 0)&#125; 体验上述案例后，是否有种当年玩“QQ游戏《大家来找茬》”的感觉。另外，这个案例可能还适用于以下两种情况： 当你不知道设计师前后两次给你的设计稿有何差异时 想查看两个浏览器对同一个网页的渲染有何差异时 何时为一个“动作”由上述“两张图像差异”的案例中可得：黑色代表该位置上的像素未发生改变，而像素越明亮则代表该点的“动作”越大。因此，当连续两帧截图合成后有明亮的像素存在时，即为一个“动作”的产生。但为了让程序不那么“敏感”，我们可以设定一个阈值。当明亮像素的个数大于该阈值时，才认为产生了一个“动作”。当然，我们也可以剔除“不足够明亮”的像素，以尽可能避免外界环境（如灯光等）的影响。 想要获取 Canvas 的像素信息，需要通过 ctx.getImageData(sx, sy, sw, sh)，该 API 会返回你所指定画布区域的像素对象。该对象包含 data、width、height。其中 data 是一个含有每个像素点 rgba 信息的一维数组，如下图所示。 获取到特定区域的像素后，我们就能对每个像素进行处理（如各种滤镜效果）。处理完后，则可通过 ctx.putImageData() 将其渲染在指定的 Canvas 上。 扩展：由于 Canvas 目前没有提供“历史记录”的功能，如需实现“返回上一步”操作，则可通过 getImageData 保存上一步操作，当需要时则可通过 putImageData 进行复原。 示例代码：1234567891011121314151617181920let imageScore = 0const rgba = imageData.datafor (let i = 0; i &lt; rgba.length; i += 4) &#123; const r = rgba[i] / 3 const g = rgba[i + 1] / 3 const b = rgba[i + 2] / 3 const pixelScore = r + g + b // 如果该像素足够明亮 if (pixelScore &gt;= PIXEL_SCORE_THRESHOLD) &#123; imageScore++ &#125;&#125;// 如果明亮的像素数量满足一定条件if (imageScore &gt;= IMAGE_SCORE_THRESHOLD) &#123; // 产生了移动&#125; 在上述案例中，你也许会注意到画面是『绿色』的。其实，我们只需将每个像素的红和蓝设置为 0，即将 rgba 的 r = 0; b = 0 即可。这样就会像电影的某些镜头一样，增加了科技感和神秘感。 体验地址&gt;&gt; 示例代码：12345678const rgba = imageData.datafor (let i = 0; i &lt; rgba.length; i += 4) &#123; rgba[i] = 0 // red rgba[i + 2] = 0 // blue&#125;ctx.putImageData(imageData, 0, 0) 将 rgba 中的 r 和 b 置为 0 跟踪“移动物体”有了明亮的像素后，我们可以取其最左上角和最右下角的两点，绘制成一个能包围所有明亮像素的矩形。这样就可以实现跟踪移动物体的效果了。 体验链接&gt;&gt; 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function processDiff (imageData) &#123; const rgba = imageData.data let score = 0 let pixelScore = 0 let motionBox = 0 // 遍历整个 canvas 的像素，以找出明亮的点 for (let i = 0; i &lt; rgba.length; i += 4) &#123; pixelScore = (rgba[i] + rgba[i+1] + rgba[i+2]) / 3 // 若该像素足够明亮 if (pixelScore &gt;= 80) &#123; score++ coord = calcCoord(i) motionBox = calcMotionBox(montionBox, coord.x, coord.y) &#125; &#125; return &#123; score, motionBox &#125;&#125;// 得到左上角和右下角两个坐标值function calcMotionBox (curMotionBox, x, y) &#123; const motionBox = curMotionBox || &#123; x: &#123; min: coord.x, max: x &#125;, y: &#123; min: coord.y, max: y &#125; &#125; motionBox.x.min = Math.min(motionBox.x.min, x) motionBox.x.max = Math.max(motionBox.x.max, x) motionBox.y.min = Math.min(motionBox.y.min, y) motionBox.y.max = Math.max(motionBox.y.max, y) return motionBox&#125;// imageData.data 是一个含有每个像素点 rgba 信息的一维数组。// 该函数是将上述一维数组的任意下标转为 (x,y) 二维坐标。function calcCoord(i) &#123; return &#123; x: (i / 4) % diffWidth, y: Math.floor((i / 4) / diffWidth) &#125;&#125; 在得到左上角和右下角的坐标值后，通过 ctx.strokeRect(x, y, width, height) API。 绘制出矩形即可。 1234567ctx.lineWidth = 6ctx.strokeRect( diff.motionBox.x.min + 0.5, diff.motionBox.y.min + 0.5, diff.motionBox.x.max - diff.motionBox.x.min, diff.motionBox.y.max - diff.motionBox.y.min) 这是理想效果，实际效果请打开 体验链接 扩展：为什么上述绘制矩形的代码中的 x、y 要加 0.5 呢？一图胜千言： 性能缩小尺寸在上一个章节提到，我们需要通过对 Canvas 每个像素进行处理，假设 Canvas 的宽为 640，高为 480，那么就需要遍历 640 * 480 = 307200 个像素。而在监测效果可接受的前提下，我们可以将需要进行像素处理的 Canvas 缩小尺寸，如缩小 10 倍。这样需要遍历的像素数量就降低 100 倍，从而提升性能。 体验地址&gt;&gt; 示例代码：12345678const motionCanvas // 展示给用户看const backgroundCanvas // offscreen canvas 背后处理数据motionCanvas.width = 640motionCanvas.height = 48backgroundCanvas.width = 64backgroundCanvas.height = 48 尺寸缩小 10 倍 定时器我们都知道，当游戏以『每秒60帧』运行时才能保证一定的体验。但对于我们目前的案例来说，帧率并不是我们追求的第一位。因此，每 100 毫秒（具体数值取决于实际情况）取当前帧与前一帧进行比较即可。 另外，因为我们的动作一般具有连贯性，所以可取该连贯动作中幅度最大的（即“分数”最高）或最后一帧动作进行处理即可（如存储到本地或分享到朋友圈）。 延伸至此，用 Web 技术实现简易的“移动监测”效果已基本讲述完毕。由于算法、设备等因素的限制，该效果只能以 2D 画面为基础来判断物体是否发生“移动”。而微软的 Xbox、索尼的 PS、任天堂的 Wii 等游戏设备上的体感游戏则依赖于硬件。以微软的 Kinect 为例，它为开发者提供了可跟踪最多六个完整骨骼和每人 25 个关节等强大功能。利用这些详细的人体参数，我们就能实现各种隔空的『手势操作』，如画圈圈诅咒某人。 下面几个是通过 Web 使用 Kinect 的库： DepthJS：以浏览器插件形式提供数据访问。 Node-Kinect2： 以 Nodejs 搭建服务器端，提供数据比较完整，实例较多。 ZigFu：支持 H5、U3D、Flash，API较为完整。 Kinect-HTML5：Kinect-HTML5 用 C# 搭建服务端，提供色彩数据、深度数据和骨骼数据。 通过 Node-Kinect2 获取骨骼数据 文章至此就真的要结束了，如果你想知道更多玩法，请关注 凹凸实验室。同时，也希望大家发掘更多玩法。 参考资料 使用HTML5开发Kinect体感游戏 MOTION DETECTION WITH JAVASCRIPT","pubDate":"Thu, 29 Jun 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/06/29/motion-detection/","category":"Web开发"},{"title":"流式分页方案探索","link":"https://aotu.io/notes/2017/06/27/infinite-scrolling/","description":"分页类型首先我们要简单认识下，何谓流式分页。分页一般用于对信息列表进行分段。根据具体功能及交互方式的不同，大致可将分页分为两种类型：传统分页和流式分页。 传统分页传统分页多用于 PC 页面，最常见于搜索结果页，如我们常用的搜索引擎 Google： 还有百度： 在京东的搜索结果页中，也可见传统分页的影子： 而在移动端页面中，限制于点击区域的大小，因此较少使用传统分页。 结合上述例子，我们可分析出，传统分页有如下几个特点： 通过页码进行分页 通过点击上/下页按钮可实现页面切换 通过点击页码可实现页面切换 可直接跳转至指定页面 多用于 PC 端 流式分页流式分页在 PC 端和移动端都有使用。PC 页面可用于对多个商品信息的展示，通过滚动的方式加载更多商品信息，如：京东首页还没逛够、发现好货等。而 H5 中，通过点击/上拉的方式来加载列表信息，也是很多见的，如京东首页为您推荐就是使用点击加上拉的方式：腾讯新闻则是通过点击的方式来加载更多信息： 结合上述例子，我们可分析出，流式分页有如下几个特点： 通过滚动/上拉/点击等方式加载新一页 无页码 无上/下页按钮 不可跳转至指定页面 pc端和移动端均有使用 传统分页和流式分页都有各自明显的优缺点，非本文重点，故不展开。有兴趣的同学可前往《Infinite Scrolling vs. Pagination》（Nick Babich 作 / Ruixi 译）查看。 流式分页的实现方案流式分页在前后端都可以实现，需根据实际情况进行决策。下面对前后端的实现及适用场景进行详细介绍。 前端分页的实现在前端分页的实现中，通过接口一次性获取列表的所有内容，根据数据的总长度和每页需展示的个数计算总页数；之后的每次加载操作（滚动/点击）中，依次执行数据截取、DOM 渲染、插入结构的过程，直至最后一页。 前端分页流程图如下： 前文提到的京东首页还没逛够就是采用前端分页的方式。在前后端的配合中，后端为前端提供如下接口：1diviner.jd.com/diviner?p=610009&amp;callback=jsonpCallbackMoreGood&amp;lid=1&amp;lim=100&amp;ec=utf-8 其中相关的参数列表如下： 参数 含义 备注 lim / limit 返回数据个数 由前端根据需要传参，或由后端设置默认值 返回数据如下： 前端将返回的 100 个数据分成两段，依次在需要加载时进行渲染插入操作。 后端根据前端的传参或约定好的数据个数，对数据进行查找。我们使用 Mongo 操作语句（后文提到的后端操作均为 Mongo）来简单表示后端的操作：1Model.find().limit(lim) 前端分页的方法适用于数据较少/分页较少的情况。 后端分页的实现在后端分页的实现中，在加载时，前端通过页码来拉数据，若返回非空数组，则进行 DOM 渲染，插入接口的操作；若返回空数组，则说明当前请求的为最后一页的数据，无需再发送请求。 后端分页流程图如下： 前文提到的发现好货就是采用后端分页的方式。在前后端的配合中，后端为前端提供如下接口：1https://ai.jd.com/index_new.php?app=Discovergoods&amp;action=getDiscZdmGoodsList&amp;callback=listCallback&amp;page=1 其中相关的参数列表如下： 参数 含义 备注 page 当前页数 由前端传参 pageSize / limit 每页数据个数 由前端根据需要传参，或由后端设置默认值 返回数据如下：非空数组： 空数组： 前端记录页数，在加载时根据返回的数据进行渲染插入操作。 后端根据前端对当前页数的传参以及每页数据个数的设置，对数据进行查找： 12const offset = (page-1) * pageSize // 跳过的个数Model.find().skip(offset).limit(pageSize) 后端分页的方法适用于数据较多/分页较多的情况。 后端分页的问题与优化存在的问题1. 数据缺失假设现在需要倒序取 20 条数据，每页展示 10 条。取第 1 页时，客户端通过page=1 pageSize=10传参，获取 20 号-11 号的数据；此时恰好另一客户端删除 17 号数据；取第 2 页时，客户端通过page=2 pageSize=10传参，offset 由原来的 20-11 变成 20-10，导致最后获取 9 号-1 号的数据。最终展示结果为 19 条，10 号数据缺失。具体过程如下： 2. 数据重复假设现在需要倒序取 20 条数据，每页展示 10 条。取第 1 页时，客户端通过page=1 pageSize=10传参，获取 20 号-11 号的数据；此时恰好另一客户端添加 21 号数据；取第 2 页时，客户端通过page=2 pageSize=10传参，offset 由原来的 20-11 变成 21-12，导致最后获取 11 号-2 号的数据。最终展示结果为 20 条，11 号数据重复。具体过程如下： 优化方案1. 使用缓存后端查询数据时，不直接对数据库进行操作，而是查找缓存的数据。缓存的方法有很多，这里介绍一种“按时间分片式缓存”的方法。前端请求数据时，除了前面提到的page和pageSize参数外，还要再传入一个timestamp参数： 请求第 1 页数据时，timestamp 传 0，服务端检查将当前系统时间赋值给 timestamp 返回 请求第 2，3，…n 页数据时，将第 1 步系统返回的 timestamp 传入 其中相关的参数列表如下： 参数 含义 备注 page 当前页数 由前端传参 pageSize 每页数据个数 由前端根据需要传参，或由后端设置默认值 timestamp 时间戳 由前端传参 后端处理时，对传入的timestamp进行判断： 若timestamp为 0，生成当前时间对应的缓存，如“data_1498705088000”，并返回前端所需数据 若timestamp不为 0 且对应的缓存不存在，返回“刷新数据”的提示 若timestamp不为 0 且有对应的缓存，则返回前端所需数据 具体过程如下：（图片来源：《浅谈APP流式分页服务端设计》） 2. 游标式分页 客户端记录当前分页的最后一条数据的 ID 请求下一页的时候，从这个 ID 开始获取一页大小的内容 其中相关的参数列表如下： 参数 含义 备注 curcor 最后一个 ID 由前端传参 pageSize 每页数据个数 由前端根据需要传参，或由后端设置默认值 后端根据前端对最后一个 ID 的传参以及每页数据个数的设置，对数据进行查找：1Model.find(&#123;id: &#123;$gt: cursor&#125;&#125;).limit(pageSize) 优点： 能够避免数据重复/遗漏 无需计算offset，性能更稳定 缺点： 只适用于按照时间追加的方式的简单排序 3. 一次性下发 ID 请求第 1 页数据之前/时先缓存所有 ID 列表 请求第 2，3，…n 页数据时，只需传入相关的 ID 列表参数 如前文提到的腾讯新闻的例子，第一次请求时（除首屏直出数据），请求所有数据的 ID 和第 1 页的数据，接口如下：1http://xw.qq.com/service/api/proxy?key=Xw@2017Mmd&amp;charset=GBK&amp;url=http://openapi.inews.qq.com/getQQNewsIndexAndItems?chlid=news_news_top&amp;refer=mobilewwwqqcom&amp;otype=jsonp&amp;t=1498706343475 返回数据如下： 之后的请求数据，将所需的 ID 列表传入，获取对应的详细信息，接口如下：1http://xw.qq.com/service/api/proxy?key=Xw@2017Mmd&amp;charset=GBK&amp;url=http://openapi.inews.qq.com/getQQNewsNormalContent?ids=20170604A063AG00,20170604A05SKQ00,20170604A05PBT00,NEW2017060403772906,NEW2017060403765707,NEW2017060403278705,20170604A06CMP00,20170604A03ZEU00,20170604A04P5900,NEW2017060402106202,20170603A07E0700,20170604A04WBM00,NEW2017060403031208,20170604A02X9900,20170604A03U6600,20170604A040JX00,20170604A04TE200,NEW2017060403727300,NEW2017060403727800,20170604A03I8200&amp;refer=mobilewwwqqcom&amp;otype=jsonp&amp;t=1496603487427 返回数据如下： 适用于 id 列表不会很大（数百条数据）的业务场景 4. 客户端排除 在客户端中保存已加载记录的 ID 每次请求完数据时，先进行数据去重 若去重数据较多，则考虑再请求下一页的数据 优点： 确保不会出现重复的数据 不改动服务器端的原有逻辑 缺点： 只适用于列表数据添加不是很频繁的情况 参考文档 《浅谈APP流式分页服务端设计》 《浅谈单页应用中前端分页的实现方案》 《APP后端分页设计》 《Infinite Scrolling vs. Pagination》 《瀑布流下拉加载更多导致数据重复怎么办》","pubDate":"Tue, 27 Jun 2017 13:00:00 GMT","guid":"https://aotu.io/notes/2017/06/27/infinite-scrolling/","category":"Web开发"},{"title":"URL编码的奥秘","link":"https://aotu.io/notes/2017/06/15/The-mystery-of-URL-encoding/","description":"URL编码的世界很精彩，你不过来看一下么？","pubDate":"Thu, 15 Jun 2017 02:41:24 GMT","guid":"https://aotu.io/notes/2017/06/15/The-mystery-of-URL-encoding/","category":"Web开发"},{"title":"10个你可能不知道的前端PS技巧","link":"https://aotu.io/notes/2017/06/09/ps-tricks/","description":"PS是各位前端开发者的基础技能，高效利用PS不仅能提高工作效率，更能带来身心上的愉悦——Jack Ma 在前端切图工作里，本质来说就是“选择图层-获取信息、编辑图层-导出图层”的过程，本文主要介绍在这个过程里的一些技巧。 1、面板这里的面板指的是在顶部主菜单“窗口”下可开启的窗口。最常用的几个窗口必属“属性”、“信息”、“图层”，屏幕够大的同学建议把它们都展开在界面右边。那为什么说这几个面板很常用呢？下面会慢慢介绍到。 2、选择图层在移动工具(V)下这个操作非常常用：option+右键/command+左键(windows:alt+右键)，在psd里快速选定图层，点哪选哪。不需要勾选“自动选择”图层选项也能快速选择图层。 而笔者比较喜欢用“option+右键”而不是“command+左键”，因为这个操作经常需要结合视图缩放(option+滚轮，windows:alt+滚轮)，这样来回切换会更方便。 3、属性面板结合快速选择图层，属性面板可以展示不少图层信息，而这些信息在开发中非常有用： 可查看文本的字体大小和颜色等 可查看形状工具(U)画出的形状的填充色和圆角等信息 可查看智能对象的宽高 可以看出属性面板主要展示的是PS比较“原生”的对象的信息。 4、信息面板“信息面板”和“属性面板”类似，只不过前者展现的信息和后者不太一样。 比如，快速选中图层后，如果在“属性面板”不能看到图层的宽高信息，可以command+T(windows:ctrl+T)打开变形操作，在“信息”面板一定可以看到图层的宽高信息，看完后记得按esc顺手退出变形工具以免不小心误操作。 妈妈再也不用担心我矩形选框工具(M)取大概估算元素的宽高值啦…… 5、吸管工具(I)这个工具最基本的功能是吸取图层颜色，这里有几个技巧可以说一下： 左键点击吸取，颜色会实时展示在“信息面板上”； 设计稿经常会看到一些不太明显的渐变色背景色的模块，怎么才能快速知道这是属于渐变色还是纯色的块？按住左键拖动吸管，颜色信息展示在“信息面板”上，通过观察即可知道到底要用background-color还是linear-gradient； 右键需要获取的颜色点，然后会出现菜单，最后一项是“拷贝颜色的十六进制代码”，这里可以快速拷贝色值供css代码用； 如果图层有不透明度，请记得先把不透明度恢复到100%才可以吸取，否则色值会不正确，右键拷贝的色值也会不对； 按住shift键然后吸取，这样会吸取多个色值，并且依次记录在“信息面板”上，这个用于对比色值很有用，在图上相应位置也会标识出顺序，如下图： 6、获取margin的另一种方式在移动工具下(V)，选中图层后，长按command(windows:长按ctrl)键，然后移动鼠标，此时鼠标停留处的图层会出现与选中图层之间的一些紫色标注的一些距离信息，这个用于获取margin比较有用。 7、复制css在图层面板，右键图层，有个“复制css”选项。这个功能在PS里很早就加进来了，可能很多同学都觉得挺鸡肋的，觉得这是给设计师学习css用的。但是其实里面的有一些信息还是挺有用的，可减少一些工作量，比如下面一段css： 123456789101112131415161718192021222324.圆角矩形_584 &#123; border-radius: 15px; background-color: rgb(0, 0, 0); opacity: 0.302; box-shadow: 6px 10.392px 121.83px 9.17px rgba(79, 48, 193, 0.004); position: absolute; left: 283px; top: 306px; width: 136px; height: 32px; z-index: 34;&#125;.矩形_1 &#123; background-image: -moz-linear-gradient( 90deg, rgb(255,255,255) 0%, rgba(255,255,255,0) 100%); background-image: -webkit-linear-gradient( 90deg, rgb(255,255,255) 0%, rgba(255,255,255,0) 100%); background-image: -ms-linear-gradient( 90deg, rgb(255,255,255) 0%, rgba(255,255,255,0) 100%); position: absolute; left: 348px; top: 572px; width: 113px; height: 78px; z-index: 25;&#125; 我们可以用到里面的圆角、背景色、透明度、阴影、宽高、渐变信息，不过说实话代码写法真的挺丑的，比如渐变那个，要进行一些人工的干预处理。不过总归可以少输入一点代码减少工作量，有些信息也不用麻烦各种手段去取、去猜…… 一般来说只是形状工具(U)画出来的形状才会有比较有用的信息，如果是图片类的图层拷贝出来的信息一般只有宽高信息可以用。 8、复制图层到新文件编辑经常会遇到一些设计稿特别大、而我们又不得不进行一些编辑的情况，很容易会出现下面的情况： 所以，从现在起你就应该这样做： 选中图层(组) 图层面板右键图层，选择“复制图层” 在弹出的面板的文档单选框里选择“新建”，如下图 接下来就可以看到在新文件里放置了该图层，然后就可以放心的进行“裁剪、变形、合并图层”等操作了……真的一点都不卡。 9、资源生成器这个功能在最新的几个版本PS里都得到支持，用于切图非常方便。具体操作方法： 首先打开设置，在“增效工具”下，勾选“启用生成器”；然后在主菜单的“文件”-“生成”，勾选“图像资源” 在图层面板选择要导出的图层，把文件名改为如“icon.png”带图片扩展名的图层名，然后就完成了资源生成的全部步骤，就这么简单。生成的资源在文件同目录下、以“-assets”结尾的文件夹里。 图层名可以怎么设置呢？下面列出了一些例子。 图层名 导出图片 logo.png 生成png-32，含透明通道 logo.png8 生成png-8 logo.png24 生成png-24，不含透明通道 img/logo.png24 资源保存在img下 logo.jpg 质量90% logo.jpg8 质量80% logo.jpg5、logo.jpg50% 质量50% 50% logo@1x.png 宽高为原图的50% 50% logo@1x.png + 100% logo@2x.png 用“+”或“,”分割可生成多份资源 图片格式还可以是gif、svg甚至webp等。可以看出资源生成器非常强大，甚至图层编辑后也会同步更新到导出的资源里。要注意图层名要唯一，否则资源会被覆盖。 以上只是一部分配置，有兴趣的同学可以参考文后资料看详细的语法。 10、微调导出的icon网页用rem单位的同学都应该知道，如果png的icon的宽高四周没有空出1像素的透明空白，网页上的icon效果四周很可能会被“吃掉”一点点。所以在icon四周留出1像素的空白很必要。“资源生成器”不能提供这种设置，但是有以下方法可以做到： 图层面板，选中图层(可按shift选多个图层，批量处理相似图层)，右键，选择“导出为” 在弹出面板可设置画布大小，宽高可设置比原来的尺寸大2像素即可，2像素会分配到上下左右各1像素。如下图： 参考资料资源生成器语法 https://helpx.adobe.com/photoshop/using/generate-assets-layers.html#specify-quality-and-size-parameters","pubDate":"Fri, 09 Jun 2017 08:30:00 GMT","guid":"https://aotu.io/notes/2017/06/09/ps-tricks/","category":"资源合集"},{"title":"canvas 图像旋转与翻转姿势解锁","link":"https://aotu.io/notes/2017/05/25/canvas-img-rotate-and-flip/","description":"多图预警，数学不好可直接跳至文末小结。 需求背景从一个游戏需求说起： 技术选型：canvas上图所展示的游戏场景，“可乐瓶”里有多个“气泡”，需要设置不同的动画效果，且涉及 deviceOrientation 的交互，需要有大量计算改变元素状态。从性能方面考虑，canvas 是不二的选择。 技术点：canvas 绘制图像通过对游戏场景的进一步分析，可见场景中的“气泡”元素形状都是相同的，且不规则，通过 canvas 直接绘制形状实现成本较高，因此需要在 canvas 上绘制图像。 技术点：canvas 图像旋转与翻转虽然“气泡”元素是相同的，可以使用相同的图像，但图像需要多个角度/多个方向展示，因此需要对图像进行相应的旋转与翻转（镜像），这也是本文所要介绍的重点。 后文代码以下图左侧绿框的“气泡”为示例，右侧展示了场景中用到的两个图像： 认识 canvas 坐标系canvas 上图像的旋转和翻转，常见的做法是将 canvas 坐标系统进行变换。因此，我们需要先认识 canvas 坐标系统：由上图可得，canvas 2D 环境中坐标系统和 Web 的坐标系统是一致的，有以下几个特点： 坐标原点 (0,0) 在左上角 X坐标向右方增长 Y坐标向下方延伸 回到上述需求中，我们获取 canvas 对象并设置相应的宽高：1&lt;canvas id='myCanvas'&gt;&lt;/canvas&gt; 123456// 获取 canvas 对象var canvas = document.getElementById('myCanvas')canvas.width = 750canvas.height = 1054// 获取 canvas 2D 上下文对象var ctx = canvas.getContext('2d') 此时，canvas 的坐标系统如下图所示： 在 canvas 上绘制图像在 canvas 上绘制图像，可以使用 drawImage() 方法，语法如下（详细用法参见 MDN）：123void ctx.drawImage(image, dx, dy);void ctx.drawImage(image, dx, dy, dWidth, dHeight);void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight); 需要注意的是，图像必须加载完毕，才能绘制到 canvas 上，否则会出现空白：123456var img = new Image()img.src = 'xxxxxxx.png'img.onload = function() &#123; // 绘制图像 ctx.drawImage(img, 512, 220, 160, 192);&#125; 此时，便可以 canvas 上看到一个未旋转/翻转的“气泡”图像，如下图所示： canvas 坐标变换接下来，我们再来了解 canvas 坐标的变换。上述需求仅涉及 2D 绘制上下文，因此仅介绍 2D 绘制上下文支持的各种变换： 平移 translate： 1ctx.translate(x, y) translate() 方法接受两个参数。x 是左右偏移量，y 是上下偏移量。 旋转 rotate： 1ctx.rotate(angle) rotate() 方法只接受一个参数。旋转的角度 angle，它是顺时针方向的，以弧度为单位的值。 缩放 scale： 1ctx.scale(x, y) scale() 方法接受两个参数。x 和 y 分别是横轴和纵轴的缩放因子。其缩放因子默认是 1，如果比 1 小是缩小，如果比 1 大则放大。 变形 transform： 1ctx.transform (a, b, c, d, e, f) transform() 方法是对当前坐标系进行矩阵变换。 1ctx.setTransform (a, b, c, d, e, f) setTransform() 方法重置变形矩阵。先将当前的矩阵重置为单位矩阵（即默认的坐标系），再用相同的参数调用 transform() 方法设置矩阵。 以上两个方法均接受六个参数，具体如下： 参数 含义 a 水平缩放绘图 b 水平倾斜绘图 c 垂直倾斜绘图 d 垂直缩放绘图 e 水平移动绘图 f 垂直移动绘图 图像旋转的实现上图所示“气泡”，宽为 160，高为 192，x 轴方向距离原点 512，y 轴方向距离原点 220，逆时针旋转 35 度。要绘制该“气泡”，需要先将坐标系平移（translate），再旋转（rotate）。具体实现步骤如下： save() 方法与 restore() 方法： save() 方法用来保存 Canvas 状态的，没有参数。每一次调用 save() 方法，当前的状态就会被推入栈中保存起来。当前状态包括： 当前应用的变形（移动/旋转/缩放） strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值 当前的裁切路径（clipping path） restore() 方法用来恢复 Canvas 状态，没有参数。每一次调用 restore() 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。 状态保存在栈中，可以嵌套使用 save() 与 restore()。 图像翻转的实现上图所示“气泡”，宽为 160，高为 192，x 轴方向距离原点 172，y 轴方向距离原点 365，顺时针旋转 35 度。要绘制该“气泡”，需要先将坐标系统平移（translate），翻转（scale），平移（translate），再旋转（rotate）。具体实现步骤如下：至此，实现了“气泡”的镜像翻转，但翻转后的“气泡”还需要旋转特定的角度，在方法一的基础上继续对坐标系统进行变换：以上操作中进行了两次平移（translate）操作，可以进行合并简化： 坐标系统的矩阵变换前文介绍了 2D 绘制上下文变形（transform）变换，实际是直接修改变换的矩阵，它可以实现前面介绍的平移（translate）／旋转（rotate）／缩放（ scale）变换，还可以实现切变/镜像反射变换等。矩阵计算遵循数学矩阵公式规则：由上公式可得：12x' = ax + cy + ey' = bx + dy + f 矩阵变换可实现以下变换效果： 平移 translate： 12x' = 1x+0y+tx = x+txy' = 0x+1y+ty = y+ty 旋转 rotate： 12x' = x*cosθ-y*sinθ+0 = x*cosθ-y*sinθy' = x*sinθ+y*cosθ+0 = x*sinθ+y*cosθ 缩放 scale： 12x' = Sx*x+0y+0 = Sx*xy' = 0x+Sy*y+0 = Sy*y 切变 12x' = x+y*tan(θx)+0 = x+y*tan(θx)y' = x*tan(θy)+y+0 = x*tan(θy)+y 镜像反射 12345// 定义(ux,uy)为直线(y=kx)方向的单位向量ux=1/sqrt(1+k^2)uy=k/sqrt(1+k^2)x' = (2*ux^2-1)*x+2*ux*uy*yy' = 2*ux*uy*x+(2*uy^2-1)*y 结合上述公式，可推导出图像旋转和翻转的矩阵变换实现： 图像旋转： 图像翻转： 图像镜像反射（翻转+旋转）： 像素操作实现图像翻转除了坐标系统变换，canvas 的像素操作同样可以实现图像的翻转。首先需要了解下 getImageData() 方法（详细用法参见MDN）和 putImageData()（详细用法参见MDN）方法： getImageData()CanvasRenderingContext2D.getImageData() 返回一个 ImageData 对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始点为 (sx, sy)、宽为 sw、高为 sh。 1ImageData ctx.getImageData(sx, sy, sw, sh); putImageData()CanvasRenderingContext2D.putImageData() 是 Canvas 2D API 将数据从已有的 ImageData 对象绘制到位图的方法。 如果提供了脏矩形，只能绘制矩形的像素。 12void ctx.putImageData(imagedata, dx, dy);void ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight); 水平翻转实现：12345678910111213141516171819202122// 绘制图像ctx.drawImage(img, x, y, width, height)// 获取 img_data 数据var img_data = ctx.getImageData(x, y, width, height), i, i2, t, h = img_data.height, w = img_data.width, w_2 = w / 2;// 将 img_data 的数据水平翻转for (var dy = 0; dy &lt; h; dy ++) &#123; for (var dx = 0; dx &lt; w_2; dx ++) &#123; i = (dy &lt;&lt; 2) * w + (dx &lt;&lt; 2) i2 = ((dy + 1) &lt;&lt; 2) * w - ((dx + 1) &lt;&lt; 2) for (var p = 0; p &lt; 4; p ++) &#123; t = img_data.data[i + p] img_data.data[i + p] = img_data.data[i2 + p] img_data.data[i2 + p] = t &#125; &#125;&#125;// 重绘水平翻转后的图片ctx.putImageData(img_data, x, y) 小结至此，小编的数学姿势又恢复到了高考水平。 图像旋转： 基础变换法： 12345ctx.save()ctx.translate(x + width / 2, y + height / 2)ctx.rotate(angle * Math.PI / 180)ctx.drawImage(img, -width / 2, -height / 2, width, height)ctx.restore() 矩阵变换法： 12345ctx.save()var rad = angle * Math.PI/180ctx.transform( Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), x + width / 2, y + height / 2)ctx.drawImage(img, -width / 2, -height / 2, width, height)ctx.restore() 图像翻转： 基础变换法： 123456// 方法一ctx.save()ctx.translate(canvasWidth, 0)ctx.scale(-1, 1)ctx.drawImage(img, canvasWidth-width-x, y, width, height)ctx.restore() 12345// 方法二ctx.save()ctx.scale(-1, 1)ctx.drawImage(img, -width-x, y, width, height)ctx.restore() 矩阵变换法： 12345// 方法一ctx.save()ctx.transform(-1, 0, 0, 1, canvasWidth, 0)ctx.drawImage(img, canvasWidth-width-x, y, width, height)ctx.restore() 12345// 方法二ctx.save()ctx.transform(-1, 0, 0, 1, 0, 0)ctx.drawImage(img, -width-x, y, width, height)ctx.restore() 像素操作法： 123456789101112131415161718ctx.drawImage(img, x, y, width, height)var img_data = ctx.getImageData(x, y, width, height), i, i2, t, h = img_data.height, w = img_data.width, w_2 = w / 2;for (var dy = 0; dy &lt; h; dy ++) &#123; for (var dx = 0; dx &lt; w_2; dx ++) &#123; i = (dy &lt;&lt; 2) * w + (dx &lt;&lt; 2) i2 = ((dy + 1) &lt;&lt; 2) * w - ((dx + 1) &lt;&lt; 2) for (var p = 0; p &lt; 4; p ++) &#123; t = img_data.data[i + p] img_data.data[i + p] = img_data.data[i2 + p] img_data.data[i2 + p] = t &#125; &#125;&#125;ctx.putImageData(img_data, x, y) 图像镜像对称（翻转+旋转）： 基础变换法： 123456ctx.save()ctx.scale(-1, 1)ctx.translate(-width/2-x, y+height/2) ctx.rotate(-angle * Math.PI / 180)ctx.drawImage(img, -width / 2, -height / 2, width, height)ctx.restore() 矩阵变换法： 1234567ctx.save()var k = Math.tan( (180-angle)/2 * Math.PI / 180 )var ux = 1 / Math.sqrt(1 + k * k)var uy = k / Math.sqrt(1 + k * k)ctx.transform( (2*ux*ux-1), 2*ux*uy, 2*ux*uy, (2*uy*uy-1), x + width/2, y + height/2 )ctx.drawImage(img, -width/2, -height/2, width, height)ctx.restore() 参考文章 《W3cplus - CANVAS 系列》 《html5 canvas.transform[转]》 《html5 canvas 学习笔记》 《在HTML5中翻转图片》 说明：本文讨论的 canvas 环境均为 2D 环境。若有更好的实现方式，欢迎留言告知。","pubDate":"Thu, 25 May 2017 15:00:00 GMT","guid":"https://aotu.io/notes/2017/05/25/canvas-img-rotate-and-flip/","category":"Web开发"},{"title":"一个例子上手SVG动画","link":"https://aotu.io/notes/2017/05/04/example-for-svg-animation/","description":"CSS3动画已足够强大，不过还是有一些它做不到的地方。配合SVG，让Web动效有更多的可能性。这次要做的效果是一个loading动画（如图）：其中旋转通过CSS来完成，但是旋转之后圆弧缩短变成笑脸的嘴巴需要借助SVG来实现。 Step1、声明SVG视口1&lt;svg width=\"100\" height=“100”&gt;&lt;/svg&gt; 指定一个宽高都为100像素的区域，width=”100”和width=”100px”是等价的，当然也可以使用其他的合法单位，例如cm、mm、em等。阅读器会设置一个默认的坐标系统，见图：左上角为原点，其中水平（x）坐标向右递增，垂直（y）坐标向下递增。 在没有指定的情况下，所有的的数值默认单位都是像素。 Step2、绘制购物袋购物袋由两个部分组成，先画下面的主体： 1&lt;path d=\"M 20 40 L 80 40 L 80 90 A 10 10 90 0 1 70 100 L 30 100 A 10 10 90 0 1 20 90\" style=\"fill: #e9e8ee;\" /&gt; 任何形状都可以使用路径元素画出，描述轮廓的数据放在它的d属性中。a.样式中的fill用来设置填充色。b.路径数据由命令和坐标构成: 指令 说明 M 20 40 表示移动画笔到(20,40) L 80 40 表示绘制一条线到(80, 40) A 10 10 90 0 1 70 100 绘制一个椭圆弧 圆弧命令以字母A开始，后面紧跟着7个参数，这7个参数分别用来表示： 椭圆的x半径和y半径 椭圆的x轴旋转角度 圆弧的角度小于180度，为0；大于或等于180度，则为1 以负角度绘制为0，否则为1 终点的x、y坐标 接下来绘制购物袋上面的部分 1&lt;path d=\"M 35 40 A 15 15 180 1 1 65 40\" style=\"fill: none; stroke: #e9e8ee; stroke-width: 5;” /&gt; 上面的部分是一个半圆弧，我同样用路径来画出，也可以使用基础形状来完成。样式中的stoke和stroke-width分别用来设置描边色和描边的宽度。 Step3、绘制眼睛12&lt;circle cx=“40\" cy=\"60\" r=\"2.5\" style=\"fill: #fff;\" /&gt;&lt;circle cx=\"60\" cy=\"60\" r=\"2.5\" style=\"fill: #fff;\" /&gt; 使用基础形状，画两个个小圆点。四个属性分别是位置坐标、半径和填充颜色。 Step4、绘制嘴巴1&lt;circle cx=\"50\" cy=\"70\" r=\"15\" style=\"fill: none; stroke: #fff; stroke-width: 5; stroke-linecap: round;transform: rotate(280deg); transform-origin: 50% 50%; stroke-dashoffset: -23; stroke-dasharray: 42, 95;”&gt; 嘴巴是一段圆弧，我绘制了一个圆，然后描边了其中的一段，并且做了一个旋转，来让它的角度处于正确的位置。 stroke-linecap：用来定义开放路径的终结,可选round|butt|square stroke-dasharray：用来创建虚线 stroke-dashoffset：设置虚线位置的起始偏移值，在下一步骤里，它会和stroke-dasharray一起用来实现动效。 Step5、给嘴巴部分添加动效1234567891011121314151617@keyframes mouth &#123; 0% &#123; transform: rotate(-80deg); stroke-dasharray: 60, 95; stroke-dashoffset: 0; &#125; 40% &#123; transform: rotate(280deg); stroke-dasharray: 60, 95; stroke-dashoffset: 0; &#125; 70%, 100% &#123; transform: rotate(280deg); stroke-dashoffset: -23; stroke-dasharray: 42, 95; &#125;&#125; 动画分为两个部分： 圆弧旋转 旋转之后缩短变形 在一个循环里，最后留有30%的时间保持一个停留。 Step6、给眼睛添加动画两只眼睛都是沿着圆弧运动 ，例如左眼，首先用一个路径来规定它的运动轨迹：1&lt;path id=\"eyeright\" d=\"M 40 60 A 15 15 180 0 1 60 60\" style=\"fill: none; stroke-width: 0;\" /&gt; 然后使用animateMotion来设置动画：12345678910&lt;circle class=\"eye\" cx=\"\" cy=\"\" r=\"2.5\" style=\"fill: #fff;\"&gt; &lt;animateMotion dur=\"0.8s\" repeatCount=\"indefinite\" keyPoints=\"0;0;1;1\" keyTimes=\"0;0.3;0.9;1\" calcMode=\"linear\"&gt; &lt;mpath xlink:href=\"#eyeleft\"/&gt; &lt;/animateMotion&gt;&lt;/circle&gt; dur：动画的时间 repeatCount：重复次数 keyPoints：运动路径的关键点 timePoints：时间的关键点 calcMode：控制动画的运动速率的变化，discrete | linear | paced | spline四个属性可选 mpath：指定一个外部定义的路径 Step7、将不同部位的动画组合到一起 眼睛的动画是从嘴巴旋转完成开始，到嘴巴变形完成结束，因此和嘴巴的动画一样，我设置了四个对应的关键时间点。 为了让衔接更顺畅，眼睛的动画开始比嘴巴变形开始稍微提前了一点点。 参考： MDN-SVG文档 《SVG精髓》- 人民邮电出版社","pubDate":"Thu, 04 May 2017 11:21:03 GMT","guid":"https://aotu.io/notes/2017/05/04/example-for-svg-animation/","category":"Web开发"},{"title":"利用视口单位实现适配布局","link":"https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/","description":"响应式布局的实现依靠媒体查询（ Media Queries ）来实现，选取主流设备宽度尺寸作为断点针对性写额外的样式进行适配，但这样做会比较麻烦，只能在选取的几个主流设备尺寸下呈现完美适配。即使是通过 rem 单位来实现适配，也是需要内嵌一段脚本去动态计算根元素大小。 近年来，随着移动端对视口单位的支持越来越成熟、广泛，使得我们可以尝试一种新的办法去真正地适配所有设备尺寸。 认识视口单位（ Viewport units )首先，我们要了解什么是视口。 在业界，极为推崇的一种理论是 Peter-Paul Koch (江湖人称“PPK大神”)提出的关于视口的解释——在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端较为复杂，它涉及到三个视口：分别是 Layout Viewport（布局视口）、 Visual Viewport（视觉视口）、Ideal Viewport。 而视口单位中的“视口”，在桌面端，毫无疑问指的就是浏览器的可视区域；但是在移动端，它指的则是三个 Viewport 中的 Layout Viewport 。 视口单位中的“视口” 根据CSS3规范，视口单位主要包括以下4个： vw : 1vw 等于视口宽度的1% vh : 1vh 等于视口高度的1% vmin : 选取 vw 和 vh 中最小的那个 vmax : 选取 vw 和 vh 中最大的那个 视口单位区别于%单位，视口单位是依赖于视口的尺寸，根据视口尺寸的百分比来定义的；而%单位则是依赖于元素的祖先元素。 用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况） 例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。 兼容性其兼容性如下图所示，可以知道：在移动端 iOS 8 以上以及 Android 4.4 以上获得支持，并且在微信 x5 内核中也得到完美的全面支持。 截图来自Can I Use 截图来自X5内核－Can I Use 利用视口单位适配页面对于移动端开发来说，最为重要的一点是如何适配页面，实现多终端的兼容，不同的适配方式各有千秋，也各有缺点。 就主流的响应式布局、弹性布局来说，通过 Media Queries 实现的布局需要配置多个响应断点，而且带来的体验也对用户十分的不友好：布局在响应断点范围内的分辨率下维持不变，而在响应断点切换的瞬间，布局带来断层式的切换变化，如同卡带的唱机般“咔咔咔”地一下又一下。 而通过采用rem单位的动态计算的弹性布局，则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得 CSS 与 JS 耦合了在一起。 有没有办法能够解决这样的问题呢？ 答案是肯定的，通过利用视口单位实现适配的页面，是既能解决响应式断层问题，又能解决脚本依赖的问题的。 做法一：仅使用vw作为CSS单位在仅使用 vw 单位作为唯一应用的一种 CSS 单位的这种做法下，我们遵守： 1.对于设计稿的尺寸转换为vw单位，我们使用Sass函数编译 12345//iPhone 6尺寸作为设计稿基准$vm_base: 375; @function vw($px) &#123; @return ($px / 375) * 100vw;&#125; 2.无论是文本还是布局高宽、间距等都使用 vw 作为 CSS 单位 1234567891011121314151617181920212223242526.mod_nav &#123; background-color: #fff; &amp;_list &#123; display: flex; padding: vm(15) vm(10) vm(10); // 内间距 &amp;_item &#123; flex: 1; text-align: center; font-size: vm(10); // 字体大小 &amp;_logo &#123; display: block; margin: 0 auto; width: vm(40); // 宽度 height: vm(40); // 高度 img &#123; display: block; margin: 0 auto; max-width: 100%; &#125; &#125; &amp;_name &#123; margin-top: vm(2); &#125; &#125; &#125;&#125; 3.1物理像素线（也就是普通屏幕下 1px ，高清屏幕下 0.5px 的情况）采用 transform 属性 scale 实现。 1234567891011121314151617181920.mod_grid &#123; position: relative; &amp;::after &#123; // 实现1物理像素的下边框线 content: ''; position: absolute; z-index: 1; pointer-events: none; background-color: #ddd; height: 1px; left: 0; right: 0; top: 0; @media only screen and (-webkit-min-device-pixel-ratio: 2) &#123; -webkit-transform: scaleY(0.5); -webkit-transform-origin: 50% 0%; &#125; &#125; ...&#125; 4.对于需要保持高宽比的图，应改用 padding-top 实现 12345678910111213.mod_banner &#123; position: relative; padding-top: percentage(100/700); // 使用padding-top height: 0; overflow: hidden; img &#123; width: 100%; height: auto; position: absolute; left: 0; top: 0; &#125;&#125; 由此，我们能够实现一个常见布局的页面效果如下： 体验地址点击此处 做法二：搭配vw和rem，布局更优化这样的页面虽然看起来适配得很好，但是你会发现由于它是利用视口单位实现的布局，依赖于视口大小而自动缩放，无论视口过大还是过小，它也随着视口过大或者过小，失去了最大最小宽度的限制。 当然，你可以不在乎这样微小的不友好用户体验，但我们还是尝试下追求修复这样的小瑕疵吧。 于是，联想到不如结合rem单位来实现布局？rem 弹性布局的核心在于动态改变根元素大小，那么我们可以通过： 给根元素大小设置随着视口变化而变化的 vw 单位，这样就可以实现动态改变其大小。 限制根元素字体大小的最大最小值，配合 body 加上最大宽度和最小宽度 这样我们就能够实现对布局宽度的最大最小限制。因此，根据以上条件，我们可以得出代码实现如下： 123456789101112131415161718192021222324// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推$vm_fontsize: 75; // iPhone 6尺寸的根元素大小基准值@function rem($px) &#123; @return ($px / $vm_fontsize ) * 1rem;&#125;// 根元素大小使用 vw 单位$vm_design: 750;html &#123; font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; // 同时，通过Media Queries 限制根元素最大最小值 @media screen and (max-width: 320px) &#123; font-size: 64px; &#125; @media screen and (min-width: 540px) &#123; font-size: 108px; &#125;&#125;// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小body &#123; max-width: 540px; min-width: 320px;&#125; 这里就不再给出截图，但你可以点击此处在线地址进行体验。 小结相对于做法一，个人比较推崇做法二，有以下两点原因： 第一，做法二相对来说用户视觉体验更好，增加了最大最小宽度的限制； 第二，更重要是，如果选择主流的rem弹性布局方式作为项目开发的适配页面方法，那么做法二更适合于后期项目从 rem 单位过渡到 vw 单位。只需要通过改变根元素大小的计算方式，你就可以不需要其他任何的处理，就无缝过渡到另一种CSS单位，更何况vw单位的使用必然会成为一种更好适配方式，目前它只是碍于兼容性的支持而得不到广泛的应用。 后语这是笔者在偶然中阅读到[翻译]使用VH和VW实现真正的流体排版这一篇文章得到的感悟与成果，也满心欢喜地期待这篇文章同样能够带给读者一些启发，并提出一些的vw单位使用秘笈来交流交流～:） 参考文档 基于视口单位的网页排版 (转）基于视口单位的网页排版 [翻译]使用VH和VW实现真正的流体排版","pubDate":"Fri, 28 Apr 2017 02:25:00 GMT","guid":"https://aotu.io/notes/2017/04/28/2017-4-28-CSS-viewport-units/","category":"Web开发"},{"title":"【译】关于 Node.js 里 ES6 Modules 的一次更新说明","link":"https://aotu.io/notes/2017/04/22/an-update-on-es6-modules-in-node-js/","description":"James M Snell IBM Technical Lead for Node.js原文链接: An Update on ES6 Modules in Node.js 几个月前，我写了一篇文章来描述 Node.js 现存的 CommonJS 模块和新的 ES6 模块系统的许多不同，也说明了在 Node.js 内核中实现这个新模型的内在的一些挑战。现在，我想分享一下关于这件事情的进展情况。 明白你什么时候该知道你需要知道的东西在这之前，如果你还没准备好，你可以花一点时间来看一下我之前的描述这两个模块架构上存在许多根本区别的文章。总结来说就是：CommonJS 与 ES6 Modules 之间的关键不同在于代码什么时候知道一个模块的结构和使用它。 举个栗子，假如我现在有一个简单的 CommonJS 模块（模块名叫&#39;foobar&#39;）： 12345678function foo() &#123; return 'bar';&#125;function bar() &#123; return 'foo';&#125;module.exports.foo = foo;module.exports.bar = bar; 现在我们在一个叫 app.js 的 JS 文件中引用它 12const &#123;foo, bar&#125; = require('foobar');console.log(foo(), bar()); 当我执行 $node app.js 的时候，Node.js 已二进制的形式加载 app.js 文件，解析它，并且开始执行里面的代码。在执行过程中，里面的 require() 方法被调用，然后它会同步的去加载 foobar.js 的内容进内存，同步的解析编译里面的 JavaScript 代码，同步的执行里面的代码，然后返回 module.exports 的值当做 app.js 里的 require(&#39;foobar&#39;) 的返回值。当 app.js 里的 require() 方法返回的时候，foobar 模块的结构就已经知道了，并且可以被使用。所有的这些事情都发生在 Node.js 进程事件循环的同一个周期里。 要理解 CommonJS 与 ES6 Modules 之间的不同至关重要的是，一个 CommonJS 的模块在没有被执行完之前，它的结构（API）是不可知的 — 即使在它被执行完以后，它的结构也可以随时被其他代码修改。 现在我们用 ES6 的写法来写同样的模块： 123456export function foo() &#123; return 'bar';&#125;export function bar() &#123; return 'foo';&#125; 并且在代码中引用它： 123import &#123;foo, bar&#125; from 'foobar';console.log(foo());console.log(bar()); 从 ECMAScript 统一的标准来看，ES6 Modules 的步骤与 CommonJS 里已经实现的有很大的不同。第一步从硬盘上加载文件内容大致上是相同的，但是可能是异步的。当内容加载完成后，会解析它。在解析的同时，模块里被 export 声明定义的结构会在组件内容被执行之前就探知出来。一旦结构被探知出来，组件的代码就会被执行。这里重要的是记住所有的 import 和 export 语句都会在代码执行之前被解析出来。另一点是在 ES6 中是允许这个解析的步骤异步执行的。这就意味着，在 Node.js 的机制中，加载脚本内容、解析模块的 import 和 export 、执行模块代码将发生在多个事件循环里。 时机很重要在评估 ES6 Modules 的可实现性之前，我们关注的重点是怎么样无缝衔接的实现它。比如我们希望它可以可以实现同时对两种模块的支持，这样可以很大程度上对用户是透明的。 可惜，事情并不是这么简单… 尤其是 ES6 Modules 的加载、解析和执行都是异步的，这就导致不能通过 require() 来引用一个 ES6 模块。原因是 require() 是一个完全同步的函数。如果我们去修改 require() 的语义让它可以进行异步加载的话，那对于现有的生态系统将会产生巨大的破坏。所以我们有考虑在 ES6 的 import() 函数提议（详情）通过之后建模实现一个 require.import() 函数。这个函数会返回一个 Promise 在 ES6 模块加载完成后标记完成。这不是最好的方案，但是它可以让你在现有的 Node.js 里以 CommonJS 的格式来使用。 有一点好消息是在 ES6 模块里可以很方便地使用 import 来引用一个 CommonJS 模块。因为在 ES6 模块里异步加载不是必须的。ECMAScript 规范进行一些小修改就可以更好地支持这种方式。但是所有这些工作过后，还有一个重要的事情… 命名引用命名引用是 ES6 Modules 里的一个基本的特性。举个例子： 1import &#123;foo, bar&#125; from 'foobar'; 变量 foo 和 bar 在解析阶段就从 foobar 中被引用进来 —— 在所有代码被执行之前。因为 ES6 Modules 的结构是之前就可以被探知到的。 另一方面，在 CommonJS 里模块结构在代码没有执行之前是不能被探知的。也就是说，如果不对 ECMAScript 规范做重大更改的话，在 CommonJS 模块里是不能使用命名引用的。开发者会引用到 ES6 Modules 里面的名为 “default” 的导出。比如，上面的例子在 CommonJS 里是这样的： 12import foobar from 'foobar';console.log(foobar.foo(), foobar.bar()); 区别很小但是很重要。所以当你想使用 import 来引用一个 CommonJS 模块的时候，下面这种写法是根本行不通的： 1import &#123;foo, bar&#125; from 'foobar'; 这里的 foo 和 bar 不会直接被解析成 CommonJS 模块里导出的 foo() 和 bar() 方法。 但是在 Babel 里可以！使用过像 Babel 这种的 ES6 Modules 语法转换工具的人应该很熟悉命名引用。Babel 的工作原理是把 ES6 的写法转换成可以在 Node.js 里运行的 CommonJS 的形式。虽然语法看起来很像 ES6，但是实际上并不是。这一点很重要，Babel 里的 ES6 命名引用与完全按照规范实现的 ES6 命名引用有本质的不同。 Michael Jackson Script实际上CommonJS 和 ES6 Modules 之间还有另外一个重要的不同就是，ECMAScript 编译器必须提前知道它加载的代码是 CommonJS 的还是 ES6 Modules 的。原因是之前说的 ES6 Modules 必须在代码执行前就解析出模块中的 import 和 export 声明。 这就意味着 Node.js 需要某些机制来预先识别它在加载那种类型的文件。在探索了很多方案以后，我们回归到了以前最糟糕的方案，就是引入一个新的 *.mjs 文件后缀来表示一个 ES6 Modules 的 JavaScript 文件。（之前我们亲切的叫它 “Michael Jackson Script”） 时间线在目前的时间点上，在 Node.js 可以开始处理支持实现 ES6 Modules 之前，还有很多关于规范现实的问题和虚拟机方面的问题。相关工作还在进行，但是需要一些时间 —— 我们目前估计至少需要一年左右。","pubDate":"Sat, 22 Apr 2017 02:09:24 GMT","guid":"https://aotu.io/notes/2017/04/22/an-update-on-es6-modules-in-node-js/","category":"NodeJS"},{"title":"Matter.js 2D 物理引擎试玩报告","link":"https://aotu.io/notes/2017/04/17/Matter-js/","description":"何为物理引擎，能做什么？物理引擎是一个计算机程序，使用质量、速度、摩擦力和空气阻力等变量，模拟了一个近似真实的物理系统，为刚性物体赋予真实的物理效果，比如重力、旋转和碰撞等效果，让物体的行为表现的更加趋向真实，例如，守望先锋的英雄在跳起时，系统所设置的重力参数就决定了他能跳多高，下落时的速度有多快，子弹的飞行轨迹等等。 四个例子不同的效果，模拟物体落入斜坡的表现 无物理效果 重力，没有碰撞效果 重力和碰撞，没有旋转效果 重力、碰撞以及旋转效果 物理引擎通常有两种常见类型：实时物理引擎和高精度物理引擎。高精度物理引擎需要更多的处理能力来计算非常精确的物理，通常使用在科学研究（计算物理学）和动画电影制作。实时物理引擎常用于电子游戏并且简化了算法，降低精确度以减少处理时间，使得在游戏中有更好的处理速度。 物理引擎在游戏中的应用CS1.5 应用的是真实度比较差的物理引擎，人物死亡后倒地动作是固定的，即使有障碍物也会执行这个动作，所以人物穿过了门。 而 CS:GO 因为采用了 Source Engine 开发，模拟较为精细，所以人物死亡之后的姿势可以根据物理学自动计算，所以可以躺在杆上，使游戏更加真实。 Matter.js 介绍Matter.js 是一个用于 Web 的 JavaScript 2D 物理引擎库，该项目诞生于 2014 年 2 月 28 号（0.5.0-alpha 版本），目前已更新迭代了 11 个版本（最新为 0.12.0 版本），它相较于老牌的 Box2D 引擎库，Matter.js 更为轻量级（压缩版仅有 84 KB），并且在性能和功能方面也不逊色。 在没有 Matter.js 前，你想去制作一个物理游戏不仅需要扎实数学知识和物理知识，并且需要通过编程语言表示出来让机器读懂。而有 Matter.js 就不一样了，它为开发者提供了许多的功能模块，通过简单易用的 API 就可以实现例如弹跳、碰撞、重力、滚动等物理效果。 Matter.js 下载首先，需要下载开发版本或者稳定版定，并将脚本加入到页面中，即可开启旅程。 1&lt;script src=\"matter.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 你也可以使用包管理工具 Bower 或 NPM 1$ bower install matter-js 1$ npm install matter-js Matter.js 支持的特性刚体复合体复合材料凹面和凸面物理特性（质量、面积、密度等）弹性（弹性和非弹性碰撞）碰撞（粗略阶段、中间阶段、精细阶段）稳定的堆叠和静止动量守恒摩擦力和阻力事件监听约束重力睡眠和静态物体圆角（倒角）视图（平移、缩放）碰撞查询（射线追踪、区域测试）时间缩放（减速、加速）Canvas 渲染器（支持向量和纹理）MatterTools 工具（创建、测试和调试）世界状态序列化，需要 resurrect.js跨浏览器（Chrome、Firefox、Safari、IE8+）兼容移动端（触摸、响应）原生 JS 实现 Matter.js 中基础的概念大多数的物理引擎对于物理模拟的要素都有着相近的概念，不同的引擎差别在于使用的方式，功能的全面性，模拟的精细度等层面，下面就先从物理世界的基础概念讲起。 Engine（引擎）和 World（世界）Matter.Engine 模块包含了创建和处理引擎的方法，引擎是负责管理和更新模拟世界的控制器，引擎可以控制时间的缩放，可以检测所有的碰撞事件，并且拿到所有碰撞的物体对（pairs）。 在 Matter.js 中任何的物体都需要一个容身处，而存放这些物体的地方，我们称之为世界，物体必须添加到世界里，然后由引擎运行这个世界。而创建世界需要使用到 Matter.World 模块，该模块包含了用于创建和操作世界的方法，一个 Matter.World 相当于一个复合物体，物体、约束、复合物体的聚合体，其次世界还有额外的一些属性，比如重力、边界。 Render（渲染）1234567891011121314// Matter.Render 用法var engine = Engine.create();// ... 将物体加入到世界中var render = Render.create(&#123; element: document.body, engine: engine, options: options&#125;);Engine.run(engine);Render.run(render); element 是一个容器元素，使用时指定要渲染的节点 engine 指定为 Matter.Engine 实例 options 指定一些渲染的参数 Matter.Render 是将实例渲染到 Canvas 中的渲染器，控制视图层的样式，它的主要作用是用于开发和调试，默认情况下 Matter.Render 将只显示物体的线框（轮廓），这对于开发和调试很有帮助，但如果需要使用到全局实体渲染则需要将线框模式关闭 render.options.wireframes = false，另外它同样也适合制作一些简单的游戏，因为它包括了一些绘图选项、线框、向量、Sprite 精灵和视窗功能。 DEMO 戳这里 Body（刚体）物体或者叫刚体，在物理引擎里特指坚硬的物体，具有固定的形状，不能形变。刚体可以用于表示一个箱子、一个球或是一块木头，每个物体都有自己的物理属性，质量、速度、摩擦力、角度等，还可以设置刚体的标记。Matter.Bodies 模块中内置了几种刚体，矩形 Matter.rectangle、多边形 Matter.polygon、圆形 Matter.circle 、梯形 Matter.trapezoid 等等。 12345678// 创建刚体var rect = Bodies.rectangle(200, 100, 50, 50), // 矩形 circle = Bodies.circle(300, 100, 25), // 圆 polygon = Bodies.polygon(450, 100, 5, 25), // 多边形 trapezoid = Bodies.trapezoid(590, 100, 50, 50, 3); // 梯形// 将刚体添加到世界中World.add(engine.world, [rect, circle, polygon, trapezoid]); DEMO 戳这里 Composite（复合体）由刚体和复合材料通过约束组合在一起的就叫做复合体。复合体对外当作一个刚体，复合体的物理属性是通过所包含的刚体的属性综合计算出来的。Matter.Composite 模块包含用于创建和处理复合体的方法，另外还有一个 Matter.Composites 模块，提供了几种特别的复合材料，例如 链 Composites.chain、牛顿摆球 Composites.newtonsCradle、软体 Composites.softBody、汽车 Composites.car 、堆叠 Composites.stack 等等。 桥梁 12345678910111213// 使用堆叠创建桥梁var group = Body.nextGroup(true);var bridge = Composites.stack(150, 300, 9, 1, 10, 10, function(x, y) &#123; return Bodies.rectangle(x, y, 50, 20, &#123; collisionFilter: &#123; // 过滤碰撞 group: group &#125; &#125;);&#125;);// 创建链约束Composites.chain(bridge, 0.5, 0, -0.5, 0, &#123; stiffness: 0.9 &#125;); DEMO 戳这里 布 12345678910// 软体var cloth = Composites.softBody(200, 200, 20, 12, 5, 5, false, 8, &#123; friction: 0.00001, // 摩擦力 collisionFilter: &#123; group: Body.nextGroup(true) &#125;, render: &#123; visible: false &#125;&#125;); DEMO 戳这里 牛顿摆球 12// 创建牛顿摆球var newtonsCradle = Composites.newtonsCradle(300, 320, 5, 25, 150); DEMO 戳这里 Constraint（约束）约束可理解为通过一条线，将刚体 A 和刚体 B 两个刚体连接起来，被约束的两个刚体由于被连接在了一起，移动就相互受到了限制。Matter.Constraint 模块包含了用于创建和处理约束的方法，这个约束可以很宽松，也可以很紧绷，还可以定义约束的距离，约束具有弹性，可以用来当作橡皮筋。 1234567891011121314151617181920212223// 创建一个矩形和圆形var rect = Bodies.rectangle(400, 100, 50, 50, &#123; isStatic: true &#125;), ball = Bodies.circle(400, 400, 50);World.add(engine.world, [ rect, ball, Constraint.create(&#123; bodyA: rect, // 约束刚体 A pointA : &#123; // 约束点 A x: 0, y: 0 &#125;, bodyB: ball, // 约束刚体 B pointB: &#123; // 约束点 B x: 0, y: -50 &#125;, stiffness: 0.6 &#125;)]); DEMO 戳这里 MouseConstraint（鼠标约束）如果你想让刚体与用户之间有交互，那就要在鼠标和刚体之间建立连接，也就是鼠标和刚体间的约束，Matter.MouseConstraint 模块包含用于创建鼠标约束的方法，提供通过鼠标或触摸（移动端时）移动刚体的能力，可以设置什么标记的物体才能被鼠标操纵，创建鼠标约束后，可以捕获到鼠标的各类事件。 123456// 全局鼠标约束var mouseConstraint = MouseConstraint.create(&#123; element: render.canvas&#125;);World.add(engine.world, mouseConstraint); 12345678910111213141516171819// 设置某个标记的物体才能被鼠标操纵var categoryBall = 0x0001; // 分类var ball = Matter.Bodies.circle(300, 350, 32, &#123; density: 0.68, // 密度 restitution: 1, // 弹性 collisionFilter: &#123; category: categoryBall &#125;&#125;);var mouseConstraint = MouseConstraint.create(&#123; element: render.canvas, collisionFilter: &#123; mask: categoryBall &#125;&#125;);World.add(engine.world, mouseConstraint); DEMO 戳这里 Vector（向量）Matter.Vector 模块包含用于创建和操纵向量的方法，向量是引擎有关几何操作行为的基础，修改物体的运动状态基本都是使用向量来控制，例如赋予物体一个力，或者设置物体的速度、旋转角度，并且内置了多个向量的求解函数：向量积、标量积、格式化、垂直向量等等。 Events（事件）Matter.Events 模块包含了绑定、移除和触发对象的方法。 绑定事件 Matter.Events.on(object, eventNames, callback) 移除事件 Matter.Events.off(object, eventNames, callback) 触发事件 Matter.Events.trigger(object, eventNames, event) Matter.js 中的一些属性施加力Matter.Body.applyForce(body, position, force) 方法可以给刚体施加一个力，传入 X 和 Y 轴需要的力度值，通过这个方法你可以去模拟踢一个足球、投一个篮球的效果。 123456789101112131415161718var ball = Bodies.circle(300, 100, 25, &#123; density: 0.68, // 密度 restitution: 0.8 // 弹性&#125;);World.add(engine.world, ball);function addForce() &#123; var forceMagnitude = 0.02 * ball.mass; Body.applyForce(ball, ball.position, &#123; x : (forceMagnitude + Common.random() * forceMagnitude) * Common.choose([1, -1]), y : -forceMagnitude + Common.random() * -forceMagnitude &#125;);&#125;addForce(); DEMO 戳这里 重力可以设置 X、Y 轴的重力值，默认都为 1，参数在 0、1、-1 中选择使用。 12345// 实现反重力效果engine.world.gravity.y = -1;// 无重力效果engine.world.gravity.y = 0; DEMO 戳这里 睡眠状态通过 enableSleeping: true 开启睡眠模式后，当刚体处于不受作用状态时，会进入睡眠状态，这样可以有效的提高引擎的性能，当物体被其他物体碰撞或者对刚体施加力时，刚体会被叫醒，引擎会继续对其进行计算模拟。 123456789// 开启睡眠状态var engine = Engine.create(&#123; enableSleeping: true&#125;);// 还可以针对进入睡眠状态的刚体进行监听，比如将刚体移出世界Event.on(ball, \"sleepStart\", function() &#123; World.remove(engine.world, ball);&#125;); DEMO 戳这里 摩擦力摩擦力在 Matter.js 中分别提供了三种：摩擦力 friction、空气摩擦力 frictionAir 以及静止摩擦力 frictionStatic。friction 默认值是 0.1，取值范围在 0 - 1，当值为 0 意味着刚体可以摩擦力的无限滑动，1 意味着对刚体施加力后会立刻停止，frictionAir 默认值是 0.01，取值范围 0 - 1，当值为 0 意味着刚体在空间中移动时速度永远不会减慢，值越高时刚体在空间的移动速度越慢，frictionStatic 默认值 0.5，当值为 0 时意味着刚体几乎是静止的，值越高时意味着需要移动刚体所需的力就越大。 1234567891011121314// 摩擦力Bodies.rectangle(300, 70, 40, 40, &#123; friction: 0.01&#125;)// 空气摩擦力Bodies.rectangle(300, 70, 40, 40, &#123; frictionAir: 0.05&#125;)// 静止摩擦力Bodies.rectangle(300, 70, 40, 40, &#123; frictionStatic: 1&#125;) 时间缩放可以控制全局的时间，当值为 0 时为冻结模拟，值为 0.1 给出慢动作效果，值为 1.2 时给出加速效果。 1engine.timing.timeScale = 0.1; 这里就简单提及到几个属性，当然还有更多的属性比如：视图（View）、弹性（Restitution）等等，更详细的 API 可到官网查看。 Matter.js 调试除了前面讲 Matter.Render 模块的时候提到的线框模式 wireframes 便于调试外，Matter.Render 模块其实还为我们提供了以下几种方法，便于我们自定义调试选项： 1234567891011121314151617181920212223242526272829var render = Render.create(&#123; element: document.body, engine: engine, options: &#123; width: 800, height: 600, pixelRatio: 1, // 设置像素比 background: '#fafafa', // 全局渲染模式时背景色 wireframeBackground: '#222', // 线框模式时背景色 hasBounds: false, enabled: true, wireframes: true, // 线框模式 showSleeping: true, // 刚体睡眠状态 showDebug: false, // Debug 信息 showBroadphase: false, // 粗测阶段 showBounds: false, // 刚体的界限 showVelocity: false, // 移动刚体时速度 showCollisions: false, // 刚体碰撞点 showSeparations: false, // 刚体分离 showAxes: false, // 刚体轴线 showPositions: false, // 刚体位置 showAngleIndicator: false, // 刚体转角指示 showIds: false, // 显示每个刚体的 ID showVertexNumbers: false, // 刚体顶点数 showConvexHulls: false, // 刚体凸包点 showInternalEdges: false, // 刚体内部边界 showMousePosition: false // 鼠标约束线 &#125;&#125;); 另外官方提供了三个调试工具，可单独使用或一起使用，如下： 工具： MatterTools.Demo 用于运行和测试 DEMO MatterTools.Gui 改变引擎的属性 MatterTools.Inspector 检查世界 官方 DEMO 戳这里 下载 MatterTools.Demo MatterTools.Gui MatterTools.Inspector (依赖jQuery) 感谢你的阅读。 参考资料Matter.js - a 2D rigid body JavaScript physics enginliabru/matter-toolsPhysics engine - WikipediaMatter.js Demo","pubDate":"Mon, 17 Apr 2017 08:01:59 GMT","guid":"https://aotu.io/notes/2017/04/17/Matter-js/","category":"Web开发"},{"title":"Sticky Footer，完美的绝对底部","link":"https://aotu.io/notes/2017/04/13/Sticky-footer/","description":"写在前面做过网页开发的同学想必都遇到过这样尴尬的排版问题：在主体内容不足够多或者未完全加载出来之前，就会导致出现（图一）的这种情况，原因是因为没有足够的垂直空间使得页脚推到浏览器窗口最底部。但是，我们期望的效果是页脚应该一直处于页面最底部（如图二）： 笔者最近在项目中也遇到过这样的场景，在寻找最佳解决方案的过程中，了解到了 “Sticky Footer” 这个名词。本文将带大家重新认识这个常见的网页效果，以及一些可行的实现方案。 什么是 “Sticky Footer”所谓 “Sticky Footer”，并不是什么新的前端概念和技术，它指的就是一种网页效果：如果页面内容不足够长时，页脚固定在浏览器窗口的底部；如果内容足够长时，页脚固定在页面的最底部。总而言之，就是页脚一直处于最底，效果大致如图所示： 当然，实现这种效果的方法有很多种，其中有通过脚本计算的，有通过 CSS 处理的，脚本计算的方案我们不在本文探讨。下面我们看看有哪些通过 CSS 可以实现且适用于移动端开发的方案，并分析其中的利弊。 如何实现假设我们页面的 HTML 结构是这样： 1234&lt;div class=\"wrapper\"&gt; &lt;div class=\"content\"&gt;&lt;!-- 页面主体内容区域 --&gt;&lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;!-- 需要做到 Sticky Footer 效果的页脚 --&gt;&lt;/div&gt;&lt;/div&gt; 实现方案一：absolute通过绝对定位处理应该是常见的方案，只要使得页脚一直定位在主容器预留占位位置。 1234567891011121314html, body &#123; height: 100%;&#125;.wrapper &#123; position: relative; min-height: 100%; padding-bottom: 50px; box-sizing: border-box;&#125;.footer &#123; position: absolute; bottom: 0; height: 50px;&#125; 这个方案需指定 html、body 100% 的高度，且 content 的 padding-bottom 需要与 footer 的 height 一致。 实现方案二：calc通过计算函数 calc 计算（视窗高度 - 页脚高度）赋予内容区最小高度，不需要任何额外样式处理，代码量最少、最简单。 123456.content &#123; min-height: calc(100vh - 50px);&#125;.footer &#123; height: 50px;&#125; 如果不需考虑 calc() 以及 vh 单位的兼容情况，这是个很理想的实现方案。同样的问题是 footer 的高度值需要与 content 其中的计算值一致。 实现方案三：table通过 table 属性使得页面以表格的形态呈现。 123456789101112html, body &#123; height: 100%;&#125;.wrapper &#123; display: table; width: 100%; min-height: 100%;&#125;.content &#123; display: table-row; height: 100%;&#125; 需要注意的是，使用 table 方案存在一个比较常见的样式限制，通常 margin、padding、border 等属性会不符合预期。笔者不建议使用这个方案。当然，问题也是可以解决的：别把其他样式写在 table 上。 实现方案四：FlexboxFlexbox 是非常适合实现这种效果的，使用 Flexbox 实现不仅不需要任何额外的元素，而且允许页脚的高度是可变的。 虽然大多数 Flexbox 布局常用于水平方向布局，但别忘了实际上它也可用于垂直布局，所以你需要做的是将垂直部分包装在一个 Flex 容器中，并选择要扩展的部分，他们将自动占用其容器中的所有可用空间。 1234567891011html &#123; height: 100%;&#125;body &#123; min-height: 100%; display: flex; flex-direction: column;&#125;.content &#123; flex: 1;&#125; 需要注意的是想要兼容各种系统设备，需要兼顾 flex 的兼容写法。 写在最后以上几种实现方案，笔者都在项目中尝试过，每个实现的方法其实大同小异，同时也都有自己的利弊。其中有的方案存在限制性问题，需要固定页脚高度；其中有的方案需要添加额外的元素或者需要 Hack 手段。同学们可以根据页面具体需求，选择最适合的方案。 当然，技术是不断更新的，也许还有很多不同的、更好的方案。但相信大家最终目都是一样的，为了更好的用户体验！ 参考资料：https://css-tricks.com/couple-takes-sticky-footer/http://www.w3cplus.com/css3/css-secrets/sticky-footers.html","pubDate":"Thu, 13 Apr 2017 04:00:00 GMT","guid":"https://aotu.io/notes/2017/04/13/Sticky-footer/","category":"移动开发"},{"title":"GPU加速是什么","link":"https://aotu.io/notes/2017/04/11/GPU/","description":"众所周知，网页不仅应该被快速加载，同时还应该流畅运行，比如快速响应的交互，如丝般顺滑的动画……一. GPU 加速能做什么？首先我们要了解什么是 16ms 优化 大多数设备的刷新频率是 60 次/秒，（1000/60 = 16.6ms）也就说是浏览器对每一帧画面的渲染工作要在 16ms 内完成，超出这个时间，页面的渲染就会出现卡顿现象，影响用户体验。 浏览器在一帧里面，会依次执行以下这些动作。减少或者避免 layout，paint 可以让页面不卡顿，动画效果更加流畅。 JavaScript：JavaScript 实现动画效果，DOM 元素操作等。 Style（计算样式）：确定每个 DOM 元素应该应用什么 CSS 规则。 Layout（布局）：计算每个 DOM 元素在最终屏幕上显示的大小和位置。由于 web 页面的元素布局是相对的，所以其中任意一个元素的位置发生变化，都会联动的引起其他元素发生变化，这个过程叫 reflow。 Paint（绘制）：在多个层上绘制 DOM 元素的的文字、颜色、图像、边框和阴影等。 Composite（渲染层合并）：按照合理的顺序合并图层然后显示到屏幕上。 利用 GPU 加速优先使用渲染层合并属性，避免 layout，paint。 从上图可以看出，可以通过改变元素的 transform 实现移动，伸缩变换而非改变物体的 left，top，width，height 避免 layout，paint。让动画效果更加流畅。 123456789@keyframes demo &#123; 0% &#123; top: 10px; &#125; 100% &#123; top: 30px; &#125;&#125; 优化123456789@keyframes demo &#123; 0% &#123; transform: translateY(10px); &#125; 100% &#123; transform: translateY(30px); &#125;&#125; 二. GPU 是什么，如何用 Chrome devtools 进行分析 debug？浏览器渲染一个页面大致是按照下面这个步骤执行。 获取 DOM 并将其分割为多个层(RenderLayer) 将每个层栅格化，并独立的绘制进位图中 将这些位图作为纹理上传至 GPU 复合多个层来生成最终的屏幕图像(终极 layer )。 Chrome 开启查看 renderlayer 按上面的步骤之后，即可看到 黄色边框：有动画 3d 变换的元素，表示放到了一个新的复合层（composited layer）中渲染 蓝色的栅格：这些分块可以看作是比层更低一级的单位，这些区域就是 RenderLayer打开一个页面，如果该页面的黄色边框很多，那么肯定要查看一下原因了 Chrome 查看 layer 打开 timeline 进行录制，选中 timeline 的某一帧，然后选择下面的 layer ，可以左右拖动该模块出现 3d。我们可以看到一个页面实际是像下面一样组成的 从上图不难理解，虽然我们最终在浏览器上看到的只是一个复印版，即最终只有一个层。类似于PhotoShop软件中的“图层”概念，最后合并所有可视图层，输出一张图片到屏幕上。但实际上一些dom会因为一些规则被提升成独立的层（开启 GPU 加速），一旦被独立出来之后，便不会再影响其他dom的布局，因为它改变之后，只是“贴上”了页面。 根据这个优点，我们可以把页面中一些布局经常变换的dom（动画）提升到独立的层。那么，浏览器在之后的 16ms 中，只需进行下面的几个步骤。 三. 如何开启 GPU 加速？目前下面这些因素都会引起Chrome创建合成层： 3D 或透视变换(perspective，transform) CSS 属性 使用加速视频解码的video元素 拥有 3D (WebGL) 上下文或加速的 2D 上下文的 canvas 元素 混合插件(如 Flash) 对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素 拥有加速 CSS 过滤器的元素 元素A有一个 z-index 比自己小的元素B，且元素B是一个合成层（换句话说就是该元素在复合层上面渲染），则元素A会提升为合成层 上面6点都非常容易理解，在日常开发中，最容易出现问题的是第7点 四. GPU 加速隐藏的坑–隐式合成 元素A有一个 z-index 比自己小的元素B，且元素B是一个合成层（换句话说就是该元素在复合层上面渲染） 拿实际项目举个栗子，我们按照上面的步骤开启 layer borders 尚未给上图右手添加高层级的 z-index 时，整个页面在移动端打开后闪退。而添加了 z-index 之后，页面正常显示，不闪退了。仔细看上面的 gif ，仅仅改变了 z-index ，就会改变大批数量的层（黄色边框） 为什么 z-index 力量这么大？我们来看一个栗子，B 在做动画，理所当然把B提到单独的合成层。减少重绘。 按照上图，我们遇到一个逻辑问题，元素B应该在单独的合成层上，并且屏幕的最终图像应该在 GPU 上组成。但是A元素在B元素的顶部，我们没有指定提升A元素自身层级的东西。那么浏览器会做什么？它将强制为元素A创建一个新的合成图层。这样，A和B都被提升到单独的复合层。因此，使用 GPU 加速提升动画性能时，最好给当前动画元素增加一个高一点的 z-index 属性，人为干扰复合层的排序，可以有效减少 Chrome 创建不必要的复合层，提升渲染性能。 注意：GPU 不仅需要发送渲染层图像到 GPU ，而且还需存储它们，以便稍后在动画中重用。别盲目创建渲染层，一定要分析其实际性能表现。因为创建渲染层是有代价的，每创建一个新的渲染层，就意味着新的内存分配和更复杂的层的管理。对于使用移动设备的用户来说是很坑的。移动设备没有台式机那么多的内存。过多的 GPU 加速会引起页面卡顿甚至闪退。 找到 layers，点击当前层，在右边查看占用的 memory（内存） 总结整篇文章介绍了下面几个部分 GPU 加速能做什么 GPU 是什么，如何用 Chrome devtools 进行分析 debug？ 如何开启 GPU 加速？ GPU 加速隐藏的坑–隐式合成 参考： http://www.jianshu.com/p/a32b890c29b1 http://div.io/topic/1348","pubDate":"Tue, 11 Apr 2017 02:25:35 GMT","guid":"https://aotu.io/notes/2017/04/11/GPU/","category":"移动开发"},{"title":"用 Git 钩子进行简单自动部署","link":"https://aotu.io/notes/2017/04/10/githooks/","description":"Git 钩子Git 钩子(hooks)是在 Git 仓库中特定事件(certain points)触发后被调用的脚本。通过钩子可以自定义 Git 内部的相关（如 git push）行为，在开发周期中的关键点触发自定义的行为。Git 含有两种类型的钩子：客户端的和服务器端的。客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。 Git 钩子最常见的使用场景包括根据仓库状态改变项目环境、接入持续集成工作流等。由于脚本是可以完全定制，所以你可以用 Git 钩子来自动化或者优化你开发工作流中任意部分。 在这篇文章中，我们会先简要介绍 Git 钩子相关要素，然后实例使用 Git 钩子进行博客自动部署。 Git 钩子安装Git 钩子存在于每个 Git 仓库的 .git/hooks 目录中。 当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或其它语言编写它们。 1234➜ hooks git:(master) lsapplypatch-msg.sample pre-applypatch.sample pre-rebase.samplecommit-msg.sample pre-commit.sample prepare-commit-msg.samplepost-update.sample pre-push.sample update.sample .sample拓展名是为了防止它们默认被执行，安装一个钩子只需要去掉.sample拓展名即可。 Git 钩子的作用域Git 钩子是对本地仓库相关操作影响，对于任何 Git 仓库来说钩子都是本地的，初始的钩子都是从 Git 默认模板目录中自动安装。 在开发团队中为了保持团队所使用钩子一致，维护起来算是比较复杂的，因为 .git/hooks 目录不随你的项目一起拷贝，也不受版本控制影响。 简单的解决办法是把钩子文件存放在项目的实际目录中（在.git 外），这样就可以像其他文件一样进行版本控制，然后在.git/hooks中创建一个链接，或者简单地在更新后把它们复制到.git/hooks目录下。 当我们了解了以上 Git 钩子基础知识后，下面我们来实例操作 Git 钩子进行博客自动部署。 Git 钩子进行自动部署如何实现 Git 钩子进行自动部署，其实原理很简单，我们只需要监听每次本地 git push到远程服务器，然后远程服务器同步拉取最新文件，重启服务器即可（pm2 reload xx）。 1.在服务器初始化一个远程 Git 裸仓库 (git init –bare) 裸仓库与 git init 初使化的仓库不太一样，裸仓库其实相当于通过克隆来的仓库里的.git文件夹，整个裸仓库中只有git索引（index），不包含工作目录。要实现 Push to Deploy，首先我们需要一个裸仓库，进入/home/USER/repos/，创建如下： 1234567git init --bare xxx-bare.git或mkdir xxx-bare.gitcd xxx-bare.gitgit init --bare 2.配置 Git Hook 将目录切换至 /home/USER/repos/xxx-bare.git/hooks，用 cp post-update.sample post-update 复制并重命名文件后 vim post-update 修改，增加执行脚本: 123456789101112#!/bin/shunset GIT_DIR DIR_ONE=/home/user/www/blog／ #此目录为服务器页面展示目录 cd $DIR_ONEgit initgit remote add origin ~/repos/xxx-bare.gitgit clean -dfgit pull origin masterpm2 restart xxx #pm2重启项目即可 注意： 一定要unset GIT_DIR清除变量， 不然会引起remote: fatal: Not a git repository: ‘.’错误。 post-update添加执行权限： 1chmod +x post-update 3.本地仓库添加 remote 源 本地仓库添加远程仓库源之后，一旦本地仓库变更提交就会触发 Git 钩子，驱动自动部署 1234git initgit remote add origin user@1.2.3.4:/home/USER/repos/xxx-bare.git #添加远程仓库源//例如git remote add origin ssh://root@41.72.11.11:26244/home/USER/repos/xxx-bare.git #远程仓库带端口写法git push origin master 最后以上就是本次 Git 钩子相关知识，希望通过本文，能让大家对 Git 钩子有一定的了解。","pubDate":"Mon, 10 Apr 2017 04:52:57 GMT","guid":"https://aotu.io/notes/2017/04/10/githooks/","category":"Web开发"},{"title":"实现一个简单但有趣的AR效果（Web）","link":"https://aotu.io/notes/2017/03/24/webar/","description":"增强现实（Augmented Reality，简称AR）：是一种实时地计算摄影机影像的位置及角度并加上相应图像、视频、3D模型的技术，这种技术的目标是在屏幕上把虚拟世界套在现实世界并进行互动。 本文将让你了解“如何通过 Web 技术实现一个简单但有趣的 AR 效果”。 实现分析正如文章开头说道：AR 是将真实环境与虚拟物体实时地叠加到一个画面。因此我们需要通过摄像头实时获取真实环境，并通过识别算法识别与分析真实环境中特定的物体，然后结合得到的数据，将虚拟物体以某种方式结合到画面中。 结合我们的案例，可得出以下步骤： 获取视频源 分析源，并识别出 Marker 位置 将虚拟物体叠加在 Marker 上 将最终画面显示在屏幕上 下面我们就根据以上步骤逐点分析。 技术分析获取视频源不依赖 Flash 或 Silverlight，我们使用 navigator.getUserMedia() API，该 API 允许 web 应用获取用户的摄像头与麦克风流（stream）。 123456789101112131415161718192021222324252627282930313233&lt;!-- 若不加 autoplay，则会停留在第一帧 --&gt;&lt;video autoplay&gt;&lt;/video&gt;navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;var video = document.querySelector('video');var constraints = &#123; video: true&#125;function successCallback(stream) &#123; // 此处利用该 window.URL 对象的 createObjectURL 方法将 blob 转为 url。 if (window.URL) &#123; video.src = window.URL.createObjectURL(stream); // 用来创建 video 可以播放的 src &#125; else &#123; video.src = stream; &#125;&#125;function errorCallback(error) &#123; console.log('navigator.getUserMedia error: ', error);&#125;if (navigator.getUserMedia) &#123; navigator.getUserMedia(&#123;video: true&#125;, successCallback, errorCallback);&#125; else &#123; console.log('getUserMedia() is not supported in your browser') video.src = 'somevideo.webm'; // fallback.&#125; 上述 API 已不被推荐，建议使用新标准 API：navigator.mediaDevices.getUserMedia()。12345navigator.mediaDevices.getUserMedia(constraints).then(function(stream) &#123; /* use the stream */&#125;).catch(function(err) &#123; /* handle the error */&#125;); 另外，可通过 constraints 参数设置以下选项： 启用 video、audio 二者其一或两者同时启用 匹配摄像头分辨率（若设备拥有不止一个摄像头） 选择前后摄像头 navigator.getUserMedia() 兼容性问题目前 IOS 设备的微信和 Safari 均不支持，较新的安卓和桌面端浏览器均支持。 另外，出于安全问题考虑，Chrome 只支持 HTTPS 页面启用摄像头。因此，我们可以用 Firefox，或者借助一些线上编辑器，如 jsbin、jsFiddle 等进行开发测试。 识别得到视频源后，我们需要对图像中的物体（本案例是 Marker）进行实时识别。下面提供两个可实现识别的库： jsaruco jsartoolkit 正如其名，它们是 aruco 和 artoolkit 的 JavaScript 版本。本文仅对第一个库进行介绍。 ArUco 是一个基于 OpenCV 的 AR 轻量库。 OpenCV（Open Source Computer Vision Library）：是一个跨平台的计算机视觉库。它可用于开发实时的图像处理、计算机视觉以及模式识别程序。 jsaruco 能识别视频每帧画面中的 Marker 位置（含 4 个角坐标）。获取坐标后，我们就能将虚拟物体放在真实环境的适当位置了。关于 jsaruco 的介绍和用法，可到 这里 查看。 结合真实环境和虚拟物体对图像的处理，Canvas（WebGL） 无疑是目前 Web 的最佳选择。 虚拟对象若是 2D 的，则直接利用 Canvas 2D API 在相应坐标上进行绘制。若虚拟对象是 3D 的，则可使用 Three.js 或 A-Frame 等 3D 库（当然，你也可以直接用 WebGL）。 如果你对 Three.js 还不了解，可以看看 《Three.js入门指南》。 另外，使用 A-Frame 可让你更快和更轻易地体验到 3D 的乐趣，仅需 10 行代码即可实现 AR，具体可阅读这篇文章 《Augmented Reality in 10 Lines of HTML》。 Marker 分析每个识别库都有其自身的实现方式。因此，一些 Marker 可能只适用于某个库。对于 jsaruco，它对 Marker 的要求如下： 一个 7x7 的正方形，其外层是“不用”的黑边。内部 5x5 单元格则组成了 ID 信息。其中，每行需要遵循以下模式： white - black - black - black - blackwhite - black - white - white - whiteblack - white - black - black - whiteblack - white - white - white - black 因此，根据上述信息，我们可以得出该库最多可识别 1024（4的5次方） 个 Marker。也就是说：每个 Marker 对应唯一一个 ID，然后我们可以利用 ID 指定显示的虚拟对象。 一个合格的 Marker 应该是这样子： 可通过这个 链接，获取 jsaruco 的更多 Marker。 当然，更先进的图像识别库不仅能识别 Marker，也可以识别你指定的图片，甚至是自然特征跟踪（ Natural Feature Tracking）和 SLAM（Simultaneous Localization and Mapping，即时定位与地图构建）。 自然特征跟踪 SLAM 实现案例建议使用带有摄像头的电脑体验以下案例（注意不要被自己的头像惊艳到~）。 另外，由于以下案例均未要求特定 ID 的 Marker，因此你可以选择以下 Marker（拍照或打印），或者在 这里 挑选一个进行体验。 Marker 想体验以下案例，需要先对某一个 Marker 拍下或打印，然后将其展示在摄像头前。 另外，为了保持文章的简洁，在此就不直接展示以下案例的实现代码。若需要，则直接查看案例源码。 再次提醒：以下案例均在电脑上进行开发测试，未针对移动端设备进行优化测试。 除了第一个案例，其余均以动画的方式展示虚拟元素。 显示 2D 图当你展示团队 Logo 时，链接&gt;&gt;。 显示心跳当你看到“男神/女神”时，链接&gt;&gt;。 显示卡片当需要展示某个人的身份信息时，链接&gt;&gt;。 显示 3D 地球当展示我们的地球母亲时，链接&gt;&gt;。 显示 3D 商品。当展示我们的商品时，链接&gt;&gt;。 最后由于笔者才疏学浅，实现的案例未必完全符合 AR 的要求。但希望通过本文，让大家能对 Web AR 有一定的了解。 参考文档 Augmented Reality in Three.js Three.js入门指南 MDN : MediaDevices.getUserMedia() js-aruco","pubDate":"Fri, 24 Mar 2017 10:00:00 GMT","guid":"https://aotu.io/notes/2017/03/24/webar/","category":"Web开发"},{"title":"轻氧 - React Native 安卓版 V1.0","link":"https://aotu.io/notes/2017/03/03/liteo2-android/","description":"距 轻氧 iOS版上一次发版本已经快一个月。 一个月可以做很多件事情，具有 加藤鹰の右手手速 的男前端童鞋可以做4到5个甚至更多的互动H5活动；但也可以只做一件事情，我们阿尔法突击队三个小伙伴过去这个月就只做了本次的 轻氧 安卓 V1.0，从交互到设计到编码实现再到申请上架。 我们慢，除了因为我们是新手（完全没有安卓 APP 开发经验，其中一名叫马克林的童鞋还是专职的 iOS 开发~），还因为我们足够用心和耐（cai）心（keng）。 我们依然是新技术控，在iOS版本中我们追随了 Swift 3.0，而在本次的安卓版本中我们选择了 React Native，尽管它的 JSX 语法相当的蹩脚丑陋，且版本号还是距离 1.0 相当遥远的 0.4x。 我们没有忘记在公众号（凹凸实验室）里留言召唤安卓版的同学们，所以现在神龙出现了。 版本功能在 iOS 版开发过程中存在版本规划过于粗放导致开发周期拖沓的问题，我们在开发安卓版前细化了版本计划，更细的版本规划可以让我们保持 小步快跑，快速迭代 的敏捷开发理念，通过 上线-反馈-修改-上线 的反复迭代来逐步改进产品。 V1.0 是一个基础版本，它的核心功能是满足大家阅读、分享和检索轻氧资讯的诉求，在此版本里你可以： 随时浏览国内外知名互联网公司的交互、设计、前端以及 APP 等资讯动态信息 一键分享资讯至微信好友/朋友圈 搜索资讯，在 10000+ 资讯中找到你最感兴趣的内容 根据大数据将资讯标签化，点击标签即可找到更多相似的文章 接收由编辑挑选出精华文章和热点资讯推送 功能自然是没有 iOS 版本丰富，我们后续会继续给它填充血肉。我们计划在 V1.1 版本中加入账户体系，在 V1.2 加入评论等简单社交功能。 此外，鉴于 RN 的局限性，相对于iOS版本我们舍弃了很多的交互动效，也因此让整个安卓版的 APP 显得更简单直接，这未尝不是一件好事。 聊聊 React Native还记得去年底我们说要用 Weex 实现安卓版本，但不好意思那只是一个漂亮的假动作 XD。经过一番调研之后，我们发现 Weex 并不适合拿来写一个独立的 APP 产品。主要来说，它有以下几点缺陷： Weex 没有完整的路由组件 目前版本还没有稳定下来，官方某些组件存在不刷新的问题 第三方插件远不如 RN 的丰富 既然如此，那市面上就只有 React Native 了。虽说《某某公司在 React Native 实践中踩过的坑》的文章也看了不少，但我们还是毅然决断地随了大流。 果不其然，在踩进了坑之后，我们在开发中也发现了 RN 的一些缺陷： ListView 并没有实现复用机制，会带来额外的性能开销 WebView 没有 onScroll 回调，需要通过消息通知方式获取滚动的偏移量 RN 的升级和降级需要小心翼翼，一不小心就碰上了大麻烦 RN 的某些动画存在掉帧的情况，特别是数据量大的情况下 当然没有技术是完美的。抛开这些缺陷来说，RN 在效率上所带来的巨大提升，还是让人十分吃惊的。相对于 iOS 原生开发来说，用上 RN 后，我们再也不必为了调样式，而去上一次厕所（等待 build 完成…）。 不仅仅是开发上带来的便利。在 APP 上线之后，如果发现有什么 bug，我们也可以利用一些热更新机制，实现静默更新。 总的来说，RN 是一个很高效而且性能不错的框架，值得你去深入尝试。 下载体验很高兴安卓 V1.0 版本已经上架了，如果你有兴趣，欢迎点击这里前往应用宝下载试用。目前应用内还没整合反馈渠道，如果你有任何的想法，欢迎在文末留言，或者给我们来信，我们会回复每一封邮件。邮箱是 aotu#jd.com(# 改为 @)。 关于也许你是轻氧的潜在用户，所以还是在文末唠叨下 轻氧 是什么。 轻氧 是 凹凸实验室 出品的一款互联网专业资讯 APP，它囊括了众多知名互联网公司、团队及网站的资讯，让你能一口气把业界最优质的专业资讯文章读完，只要你这口气够长。 轻氧 精心选出了一些知名的 UED 和互联网站点，基于其简易信息聚合协议（RSS），将优质的互联网内容包装和分发，聚集到一个平台。 轻氧 搬运但不盗窃，如果你喜欢，你仍然可以把「轻氧」当成是一款RSS订阅器，尽管我们不止于订阅辣么简单，后续我们APP做开源分享的时候再做深入介绍。 经过半年时间的耕耘，轻氧目前已有超过 11000 篇资讯，来自于 40+ 资讯来源： 未来，我们还将在保证高质量文章的基础上，聚合更多的来源。","pubDate":"Fri, 03 Mar 2017 08:45:36 GMT","guid":"https://aotu.io/notes/2017/03/03/liteo2-android/","category":"移动开发"},{"title":"移动端真机调试指南","link":"https://aotu.io/notes/2017/02/24/Mobile-debug/","description":"导语：随着移动设备的普及以及微信庞大的用户量，移动端的需求也随之爆发式增长，平时我们使用 Chrome 进行手机模拟页面开发，但模拟终究是模拟，不可避免的还是需要真机调试，下面就来讲讲几种调试方案，希望能对你有所帮助。 系统自带调试功能iOS 系统运行环境要求 Mac + Safari 浏览器 iPhone（iOS 6 +） + Safari 浏览器 调试步骤 1、使用 Lightning 数据线将 iPhone 与 Mac 相连 2、iPhone 开启 Web 检查器（设置 -&gt; Safari -&gt; 高级 -&gt; 开启 Web 检查器） 3、iPhone 使用 Safari 浏览器打开要调试的页面 4、Mac 打开 Safari 浏览器调试（菜单栏 —&gt; 开发 -&gt; iPhone 设备名 -&gt; 选择调试页面） 如果你的菜单栏没有“开发”选项，可以到左上角 Safari -&gt; 偏好设置 -&gt; 高级 -&gt; 在菜单栏中显示“开发”菜单。 5、在弹出的 Safari Developer Tools 中调试 经过如上步骤就可在 Mac 端调试 iPhone 上 Safari 运行的页面了，但对于 WebView 页面就不适用了，另外 Windows 系统不适用此方案。 当前测试环境： Safari 版本 10.0.2 iPhone 7（iOS 10.1.1） 没有 iPhone 设备可以在 App Store 安装 Xcode 使用其内置的 iOS 模拟器，安装完成后通过以下两种方式开启： 右键 Xcode 图标 -&gt; Open Developer Tool -&gt; Simulator 右键 Finder 图标 -&gt; 前往文件夹 -&gt; /应用程序/Xcode.app/Contents/Developer/Applications/ -&gt; 运行 Simulator.app 运行 iOS 模拟器后，在模拟器中打开调试页面，再通过 Mac Safari 开发功能就可以调试到。 如果我需要调试更低版本的 iOS 怎么办？实际使用的 iPhone 不可能去降版本，不必担心，Simulator 有。 点击左上角 Xcode -&gt; Preferences -&gt; Downloads 就可以看到提供了如下版本： Android 系统运行环境要求 Chrome 版本 &gt;= 32 Android 版本 4.0 + 调试步骤 1、使用 USB 数据线将手机与电脑相连 2、手机进入开发者模式，勾选 USB 调试，并允许调试 如何开启 USB 调试： 索尼 Z5：设置 -&gt; 关于关机 -&gt; 多次点击软件版本开启 -&gt; 返回上一级 -&gt; 开发者选项 -&gt; USB 调试 魅蓝 Note：设置 -&gt; 辅助功能 -&gt; 开发者选项 -&gt; USB 调试 不同 Android 设备进入开发者模式的方式有稍稍不同，瞎捣鼓一下即可开启。 3、电脑打开 Chrome 浏览器，在地址栏输入：chrome://inspect/#devices 并勾选 Discover USB devices 选项 4、手机允许远程调试，并访问调试页面 官方的教程是想让你使用手机 Chrome 开启调试页面的，但实际需求更多的是调试一些 WebView 页面，在官方的 Remote Debugging WebViews 有说明是可以调试 WebView 页面的，Android 版本需要在 4.4 以上，并且 APP 需要有配置相应的启动调试代码。 WebView debugging must be enabled from within your application. To enable WebView debugging, call the static method setWebContentsDebuggingEnabled on the WebView class. 必须在 APP 内启动 WebView 调试。要启动 WebView 调试，需要调用 WebView 类上的静态方法 setWebContentsDebuggingEnabled。 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true);&#125; This setting applies to all of the application’s WebViews. 此设置适用于所有 APP 的 WebView。 Tip: WebView debugging is not affected by the state of the debuggable flag in the application’s manifest. If you want to enable WebView debugging only when debuggable is true, test the flag at runtime. 提示：WebView 是否可调试状态不受 mainfest 标志变量 debuggable 的影响，如果你想在 debuggable 为 true 的时候启动 WebView 调试，请使用以下代码： 12345if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; if (0 != (getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE)) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125;&#125; 5、电脑点击 inspect 按钮 如果你出现无法识别到设备的情况，建议尝试以下几种方法： 使用原装数据线，不要使用山寨数据线或一线多头的数据线 重新插拔 USB 数据线，让手机处于充电状态 关闭电脑相关的应用助手 重启手机 Windows 系统下自动安装驱动失败，到 Android Studio 手动下载 注意：使用 Chrome Inspect 查看页面时，Chrome 需要从 https://chrome-devtools-frontend.appspot.com 加载资源，如果你得到的调试界面是一片空白，那你可能需要科学上网。 6、进入调试界面 当前测试环境： Chrome 版本 55.0.2883.95 索尼 Z5（Android 5.1.1） 魅蓝 Note（Android 5.1） 三星 Galaxy S7（Android 6.0.1） 这里顺带提一下 TBS Studio 调试工具，它在 Chrome DevTools 调试功能的基础上进行了一些功能扩展，特性如下： 1.3 TBS Studio 功能特性 1）自动检测手机与 PC 的连接；2）自动检测网页是否可进行 Inspect 调试；3）自动引导开发者打开 Inspector 调试开关；4）一键开启 Inspector 调试，无需打开浏览器输入 URL，方便快捷；5）扩展 X5 内核独有 Inspect 选项，方便页面分析和优化；6）真机远程 Inspector 调试。 详细介绍和使用步骤可到开发者论坛查看，部分 Android 机型通过 USB 可能依旧无法识别到设备，可使用后面会讲到的其他方案。 关于 Android 虚拟机也是有的，这里推荐使用 Genymotion 软件，使用 Genymotion 前需要安装 VirtuaBox，并且注册登陆后才能显示所有的虚拟设备。 使用代理工具调试开发环境页面对于需要配 Hosts 才能访问的开发环境页面，手机在默认情况下是没有权限修改 Hosts 文件的，除非是 iOS 设备越狱后和 Android 设备 root 后，所以一般情况下手机是无法访问开发环境页面，这时需要使用到 Mac 系统的 Charles 代理工具，Windows 系统可使用 Fiddler 代理工具。 实现思路 Mac 作为代理服务器 手机通过 HTTP 代理连接到 Mac 电脑 手机上的请求都经过代理服务器 通过给 Mac 配 Hosts 实现目的 调试步骤 1、查看电脑 IP（菜单 -&gt; Help -&gt; Local IP Addresses） 2、查看端口（菜单 -&gt; Settings -&gt; Proxy Settings -&gt; Proxies） 默认端口为：8888，勾选 Enable transparent HTTP proxying 3、将 IP、端口号填入手机 HTTP 代理 iOS 系统：设置 -&gt; 无线局域网 -&gt; 点击叹号 -&gt; HTTP 代理 -&gt; 手动 Android 系统：设置 -&gt; 长按当前网络 -&gt; 修改网络 -&gt; 高级选项 -&gt; 手动 4、Charles 允许授权 每次有新设备首次连接都会提示是否授权，可以通过 Proxy -&gt; Access Control Settings 配置以下参数 0.0.0.0/0 来关闭。 5、使用 SwitchHosts! 软件给 Mac 电脑配 Hosts 6、手机访问开发环境页面 到这一步手机就可以访问到开发环境下的页面了，再结合前面所讲的方案来调试页面。 7、Charles 的调试功能 7.1 网络映射修改文件 除了结合前面的方案调试，可以使用 Map Local 网络映射功能来实现对文件的修改，在菜单 -&gt; Proxy -&gt; Start Recording 开启抓包后访问页面，找到抓取到的样式文件，点击右键 Map Local，在 Local path 中设置本地映射文件的路径，修改后刷新页面可以看到效果。 7.2 模拟网络速度 菜单 -&gt; Proxy -&gt; Throttle Settings -&gt; 勾选 Enable Throttling，在 Throttling preset 中可以选择需要模拟的网络速度。 7.3 抓取 HTTPS 请求 默认情况下，Charles 无法抓取到 HTTPS 的请求，解决步骤如下： Mac 端安装证书：菜单 -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate 然后导出 Charles SSL 证书安装到手机，菜单 -&gt; Help -&gt; SSL Proxying -&gt; Save Charles Root Certificate Android 设备导出的 Charles SSL 证书存储到手机中并安装。 iOS 设备用 Safari 打开 http://www.charlesproxy.com/getssl/ 页面，下载 Charles SSL 证书并安装。 证书安装完成后，还需要给 Charles SSL 代理配置域名和端口号，菜单 -&gt; Proxy -&gt; SSL Proxying Settings 勾选 Enable SSL Proxying 点击 Add 填入域名和端口号，经过以上步骤就可以抓取到 HTTPS 的请求了。 7.4 断点调试请求和响应内容 开启 Charles 断点 Proxy -&gt; Breakpoints Settings -&gt; Enable Breakpoints点击 Add 可设置断点条件或者单独对需要的文件右键 Breakpoints 设置断点。 访问页面后，即可编辑请求和响应的内容，点击 Execute 按钮完成。 Weinre 调试工具Weinre 是一款较老的远程调试工具，功能与 Chrome DevTools 相似，需要在页面中插入一段 JS 脚本来实时调试页面 DOM 结构、样式、JS 等，另外它使用的是代理的方式，所以兼容性很好，无论是新老设备系统通吃，但对于样式调试不友善，缺少断点调试及 Profiles 等常用功能。 调试步骤： 1、安装 Weinre 使用 NPM 全局安装 Weinre 1$ sudo npm -g install weinre 2、启动 Weinre 监听服务 12$ ipconfig getifaddr en0 // 查看本机 IP$ weinre --boundHost 10.14.217.14 --httpPort 8090 --boundHost 后填入你本机 IP 地址，--httpPort 后填入端口号，默认为 8080 3、进入 Weinre 管理页面 使用 Chrome 浏览器访问 http://10.14.217.14:8090，在管理页面你可以看到使用相关的说明，有进入客户端调试界面的地址、使用的文档、DEMO 页面等等，说明中要求将一段 JS 脚本 &lt;script src=&quot;http://10.14.217.14:8090/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt; 插入到需要调试的页面中，插入代码后手机访问调试页面。 4、进入客户端调试界面 点击 debug client user interface：http://10.14.217.14:8090/client/#anonymous 的链接。 5、JS 脚本注入 手动加入 JS 脚本不优雅，这里可以结合我们前面提到的 Charles 代理工具实现动态 HTTP Script 注入。 打开菜单 -&gt; Rewrite -&gt; 勾选 Enable Rewrite 输入 Rewrite 的名字并且在 Rules 一项添加匹配的规则，Location 一项是用于指定的域名和端口添加规则用的，这里我们不填默认匹配所有请求。 Type 允许对需要匹配的请求进行 Rewrite，一共提供了 11 种： Add Header Modify Header Remove Header Host Path URL Add Query Param Modify Query Param Remove Query Param Response Status Body 这里我们需要使用到的是 Body，它的作用是对请求或响应内容进行匹配替换，按照下图的配置，通过将匹配到的响应内容 &lt;/body&gt; 标签替换成需要插入到页面中的 JS 脚本，从而实现动态插入。 另外，也有基于 Weinre 进行功能扩展的工具，比如早期版本的 微信 Web 开发者工具 v0.7.0 和 spy-debugger，都在 Weinre 的基础上简化了要给每个调试页面添加 JS 脚本的步骤，spy-debugger 还增加了对 HTTPS 的支持。 感谢你的阅读，如果你还有其他更为实用的调试方案，欢迎下方留言交流。 参考资料 Safari Web Inspector Guide Get Started with Remote Debugging Android Devices Remote Debugging WebViews weinre - Running Charles Web Debugging Proxy wuchangming/spy-debugger TBS 开发调试利器 —— TBS Studio - QQ 浏览器移动产品论坛 微信 web 开发者工具","pubDate":"Fri, 24 Feb 2017 06:45:36 GMT","guid":"https://aotu.io/notes/2017/02/24/Mobile-debug/","category":"Web开发"},{"title":"“等一下，我碰！”——常见的2D碰撞检测","link":"https://aotu.io/notes/2017/02/16/2d-collision-detection/","description":"“碰乜鬼嘢啊，碰走晒我滴靓牌”。想到“碰”就自然联想到了“麻将”这一伟大发明。当然除了“碰”，洗牌的时候也充满了各种『碰撞』。 好了，不废话。直入主题——碰撞检测。 在 2D 环境下，常见的碰撞检测方法如下： 外接图形判别法 轴对称包围盒（Axis-Aligned Bounding Box），即无旋转矩形。 圆形碰撞 圆形与矩形（无旋转） 圆形与旋转矩形（以矩形中心点为旋转轴） 光线投射法 分离轴定理 其他 地图格子划分 像素检测 下文将由易到难的顺序介绍上述各种碰撞检测方法：外接图形判别法 &gt; 其他 &gt; 光线投射法 &gt; 分离轴定理。 另外，有一些场景只要我们约定好限定条件，也能实现我们想要的碰撞，如下面的碰壁反弹： See the Pen Boundary collision detection by Jc (@JChehe) on CodePen. 当球碰到边框就反弹(如x/y轴方向速度取反)。 12if(ball.left &lt; 0 || ball.right &gt; rect.width) ball.velocityX = -ball.velocityXif(ball.top &lt; 0 || ball.bottom &gt; rect.height) ball.velocityY = -ball.velocityY 再例如当一个人走到 100px 位置时不进行跳跃，就会碰到石头等等。 因此，某些场景只需通过设定到适当的参数即可实现碰撞检测。 外接图形判别法轴对称包围盒（Axis-Aligned Bounding Box）概念：判断任意两个（无旋转）矩形的任意一边是否无间距，从而判断是否碰撞。 算法： 1234rect1.x &lt; rect2.x + rect2.width &amp;&amp;rect1.x + rect1.width &gt; rect2.x &amp;&amp;rect1.y &lt; rect2.y + rect2.height &amp;&amp;rect1.height + rect1.y &gt; rect2.y 两矩形间碰撞的各种情况： 在线运行示例（先点击运行示例以获取焦点，下同）： See the Pen AxisAlignedBoundingBox collision detection by Jc (@JChehe) on CodePen. 缺点： 相对局限：两物体必须是矩形，且均不允许旋转（即关于水平和垂直方向上对称）。 对于包含着图案（非填满整个矩形）的矩形进行碰撞检测，可能存在精度不足的问题。 物体运动速度过快时，可能会在相邻两动画帧之间快速穿越，导致忽略了本应碰撞的事件发生。 适用案例： （类）矩形物体间的碰撞。 圆形碰撞（Circle Collision）概念：通过判断任意两个圆形的圆心距离是否小于两圆半径之和，若小于则为碰撞。 两点之间的距离由以下公式可得： 判断两圆心距离是否小于两半径之和： 123Math.sqrt(Math.pow(circleA.x - circleB.x, 2) + Math.pow(circleA.y - circleB.y, 2)) &lt; circleA.radius + circleB.radius 图例： 在线运行示例： See the Pen EZrorG by Jc (@JChehe) on CodePen. 缺点： 与『轴对称包围盒』类似 适用案例： （类）圆形的物体，如各种球类碰撞。 圆形与矩形（无旋转）概念：通过找出矩形上离圆心最近的点，然后通过判断该点与圆心的距离是否小于圆的半径，若小于则为碰撞。 那如何找出矩形上离圆心最近的点呢？下面我们从 x 轴、y 轴两个方向分别进行寻找。为了方便描述，我们先约定以下变量： 123矩形上离圆心最近的点为变量：closestPoint = &#123;x, y&#125;;矩形 rect = &#123;x, y, w, h&#125;; // 左上角与宽高圆形 circle = &#123;x, y, r&#125;; // 圆心与半径 首先是 x 轴： 如果圆心在矩形的左侧（if(circle.x &lt; rect.x)），那么 closestPoint.x = rect.x。 如果圆心在矩形的右侧（else if(circle.x &gt; rect.x + rect.w)），那么 closestPoint.x = rect.x + rect.w。 如果圆心在矩形的正上下方（else），那么 closestPoint.x = circle.x。 同理，对于 y 轴（此处不列举图例）： 如果圆心在矩形的上方（if(circle.y &lt; rect.y)），那么 closestPoint.y = rect.y。 如果圆心在矩形的下方（else if(circle.y &lt; rect.y + rect.h)），那么 closestPoint.y = rect.y + rect.h。 圆形圆心在矩形的正左右两侧（else），那么 closestPoint.y = circle.y。 因此，通过上述方法即可找出矩形上离圆心最近的点了，然后通过『两点之间的距离公式』得出『最近点』与『圆心』的距离，最后将其与圆的半径相比，即可判断是否发生碰撞。 1234var distance = Math.sqrt(Math.pow(closestPoint.x - circle.x, 2) + Math.pow(closestPoint.y - circle.y, 2))if(distance &lt; circle.r) return true // 发生碰撞else return false // 未发生碰撞 在线运行示例： See the Pen Circle and Rectangle by Jc (@JChehe) on CodePen. 缺点： 矩形需是轴对称的，即不能旋转。 圆形与旋转矩形（以矩形中心为旋转轴）概念：即使矩形以其中心为旋转轴进行了旋转，但是判断它与圆形是否发生碰撞的本质还是找出矩形上离圆心的最近点。 对于旋转后的矩形，要找出其离圆心最近的点，视乎有些困难。其实，我们可以将我们思想的范围进行扩大：将矩形的旋转看作是整个画布的旋转。那么我们将画布（即 Canvas）反向旋转『矩形旋转的角度』后，所看到的结果就是上一个方法“圆形与矩形（无旋转）”的情形。因此，我们只需求出画布旋转后的圆心位置，即可使用『圆形与矩形（无旋转）』的判断方法了。 先给出可直接套用的公式，从而得出旋转后的圆心坐标：12x’ = cos(β) * (cx – centerX) – sin(β) * (cy – centerY) + centerXy’ = sin(β) * (cx – centerX) + cos(β) * (cy – centerY) + centerY 下面给出该公式的推导过程： 根据下图，计算某个点绕另外一个点旋转一定角度后的坐标。我们设 A(x,y) 绕 B(a,b) 旋转 β 度后的位置为 C(c,d)。 设 A 点旋转前的角度为 δ，则旋转（逆时针）到 C 点后的角度为(δ+β) 由于 |AB| 与 |CB| 相等（即长度），且 |AB| = y/sin(δ) = x / cos(δ) |CB| = d/sin(δ + β) = c / cos(δ + β) 半径 r = x / cos(δ) = y / sin(δ) = d / sin(δ + β) = c / cos(δ + β) 由以下三角函数两角和差公式： sin(δ + β) = sin(δ)cos(β) + cos(δ)sin(β) cos(δ + β) = cos(δ)cos(β) - sin(δ)sin(β) 可得出旋转后的坐标： c = r * cos(δ + β) = r * cos(δ)cos(β) - r * sin(δ)sin(β) = x * cos(β) - y * sin(β) d = r * sin(δ + β) = r * sin(δ)cos(β) + r * cos(δ)sin(β) = y * cos(β) + x * sin(β) 由上述公式推导后可得：旋转后的坐标 (c,d) 只与旋转前的坐标 (x,y) 及旋转的角度 β 有关。 当然，(c,d) 是旋转一定角度后『相对于旋转点（轴）的坐标』。因此，前面提到的『可直接套用的公式』中加上了矩形的中心点的坐标值。 从图中也可以得出以下结论：A 点旋转后的 C 点总是在圆周（半径为 |AB|）上运动，利用这点可让物体绕旋转点（轴）做圆周运动。 得到旋转后的圆心坐标值后，即可使用『圆形与矩形（无旋转）』方法进行碰撞检测了。 在线运行案例： See the Pen Circle and Rotated Rectangle Collision Detection by Jc (@JChehe) on CodePen. 优点： 相对于圆形与矩形（未旋转）的方法，适用范围更广。 其他地图格子划分概念：将地图（场景）划分为一个个格子。地图中参与检测的对象都存储着自身所在格子的坐标，那么你即可以认为两个物体在相邻格子时为碰撞，又或者两个物体在同一格才为碰撞。另外，采用此方式的前提是：地图中所有可能参与碰撞的物体都要是格子单元的大小或者是其整数倍。 蓝色X 为障碍物： 实现方法： 12345678910111213// 通过特定标识指定（非）可行区域map = [ [0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0]],// 设定角色的初始位置player = &#123;left: 2, top: 2&#125;// 移动前（后）判断角色的下一步的动作（如不能前行）... 在线运行示例： See the Pen map cell collision detection by Jc (@JChehe) on CodePen. 缺点： 适用场景局限。 适用案例： 推箱子、踩地雷等 像素检测概念：以像素级别检测物体之间是否存在重叠，从而判断是否碰撞。 实现方法有多种，下面列举在 Canvas 中的两种实现方式： 如下述的案例中，通过将两个物体在 offscreen canvas 中判断同一位置（坐标）下是否同时存在非透明的像素。 利用 canvas 的 globalCompositeOperation = &#39;destination-in&#39; 属性。该属性会让两者的重叠部分会被保留，其余区域都变成透明。因此，若存在非透明像素，则为碰撞。 注意，当待检测碰撞物体为两个时，第一种方法需要两个 offscreen canvas，而第二种只需一个。 offscreen canvas：与之相关的是 offscreen rendering。正如其名，它会在某个地方进行渲染，但不是屏幕。“某个地方”其实是内存。渲染到内存比渲染到屏幕更快。—— Offscreen Rendering 当然，我们这里并不是利用 offscreen render 的性能优势，而是利用 offscreen canvas 保存独立物体的像素。换句话说：onscreen canvas 只是起展示作用，碰撞检测是在 offscreen canvas 中进行。 另外，由于需要逐像素检测，若对整个 Canvas 内所有像素都进行此操作，无疑会浪费很多资源。因此，我们可以先通过运算得到两者相交区域，然后只对该区域内的像素进行检测即可。 图例： 下面示例展示了第一种实现方式： See the Pen pixel collision detection by Jc (@JChehe) on CodePen. 缺点： 因为需要检查每一像素来判定是否碰撞，性能要求比较高。 适用案例： 需要以像素级别检测物体是否碰撞。 光线投射法（Ray Casting）概念：通过检测两个物体的速度矢量是否存在交点，且该交点满足一定条件。 对于下述抛小球入桶的案例：画一条与物体的速度向量相重合的线(#1)，然后再从另一个待检测物体出发，连线到前一个物体，绘制第二条线(#2)，根据两条线的交点位置来判定是否发生碰撞。 抛球进桶图例： 在小球飞行的过程中，需要不断计算两直线的交点。 当满足以下两个条件时，那么应用程序就可以判定小球已落入桶中： 两直线交点在桶口的左右边沿间 小球位于第二条线（#2）下方 在线运行示例： See the Pen ray casting collision detection by Jc (@JChehe) on CodePen. 优点： 适合运动速度快的物体 缺点： 适用范围相对局限。 适用案例： 抛球运动进桶。 分离轴定理（Separating Axis Theorem）概念：通过判断任意两个 凸多边形 在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。 图例： 在程序中，遍历所有角度是不现实的。那如何确定 投影轴 呢？其实投影轴的数量与多边形的边数相等即可。 以较高抽象层次判断两个凸多边形是否碰撞： 123456789101112131415161718function polygonsCollide(polygon1, polygon2) &#123; var axes, projection1, projection2 // 根据多边形获取所有投影轴 axes = polygon1.getAxes() axes.push(polygon2.getAxes()) // 遍历所有投影轴，获取多边形在每条投影轴上的投影 for(each axis in axes) &#123; projection1 = polygon1.project(axis) projection2 = polygon2.project(axis) // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。 if(!projection1.overlaps(projection2)) return false &#125; return true&#125; 上述代码有几个需要解决的地方： 如何确定多边形的各个投影轴 如何将多边形投射到某条投影轴上 如何检测两段投影是否发生重叠 投影轴如下图所示，我们使用一条从 p1 指向 p2 的向量来表示多边形的某条边，我们称之为边缘向量。在分离轴定理中，还需要确定一条垂直于边缘向量的法向量，我们称之为“边缘法向量”。 投影轴平行于边缘法向量。投影轴的位置不限，因为其长度是无限的，故而多边形在该轴上的投影是一样的。该轴的方向才是关键的。 12345678// 以原点(0,0)为始，顶点为末。最后通过向量减法得到 边缘向量。var v1 = new Vector(p1.x, p1.y) v2 = new Vector(p2.x, p2.y)// 首先得到边缘向量，然后再通过边缘向量获得相应边缘法向量（单位向量）。// 两向量相减得到边缘向量 p2p1（注：上面应该有个右箭头，以表示向量）。// 设向量 p2p1 为(A,B)，那么其法向量通过 x1x2+y1y2 = 0 可得：(-B,A) 或 (B,-A)。 axis = v1.edge(v2).normal() 以下是向量对象的部分实现，具体可看源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var Vector = function(x, y) &#123; this.x = x this.y = y&#125;Vector.prototype = &#123; // 获取向量大小（即向量的模），即两点间距离 getMagnitude: function() &#123; return Math.sqrt(Math.pow(this.x, 2), Math.pow(this.y, 2)) &#125;, // 点积的几何意义之一是：一个向量在平行于另一个向量方向上的投影的数值乘积。 // 后续将会用其计算出投影的长度 dotProduct: function(vector) &#123; return this.x * vector.x + this.y + vector.y &#125;, // 向量相减 得到边 subtarct: function(vector) &#123; var v = new Vector() v.x = this.x - vector.x v.y = this.y - vector.y return v &#125;, edge: function(vector) &#123; return this.substract(vector) &#125;, // 获取当前向量的法向量（垂直） perpendicular: function() &#123; var v = new Vector() v.x = this.y v.y = 0 - this.x return v &#125;, // 获取单位向量（即向量大小为1，用于表示向量方向），一个非零向量除以它的模即可得到单位向量 normalize: function() &#123; var v = new Vector(0, 0) m = this.getMagnitude() if(m !== 0) &#123; v.x = this.x / m v.y = this.y /m &#125; return v &#125;, // 获取边缘法向量的单位向量，即投影轴 normal: function() &#123; var p = this.perpendicular() return p .normalize() &#125;&#125; 向量相减 更多关于向量的知识可通过其它渠道学习。 投影投影的大小：通过将一个多边形上的每个顶点与原点(0,0)组成的向量，投影在某一投影轴上，然后保留该多边形在该投影轴上所有投影中的最大值和最小值，这样即可表示一个多边形在某投影轴上的投影了。 判断两多边形的投影是否重合：projection1.max &gt; projection2.min &amp;&amp; project2.max &gt; projection.min 为了易于理解，示例图将坐标轴原点(0,0)放置于三角形边1投影轴的适当位置。 由上述可得投影对象： 123456789101112// 用最大和最小值表示某一凸多边形在某一投影轴上的投影位置var Projection = function (min, max) &#123; this.min this.max&#125;projection.prototype = &#123; // 判断两投影是否重叠 overlaps: function(projection) &#123; return this.max &gt; projection.min &amp;&amp; projection.max &gt; this.min &#125;&#125; 如何得到向量在投影轴上的长度？向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2 123456789101112// 根据多边形的每个定点，得到投影的最大和最小值，以表示投影。function project = function (axis) &#123; var scalars = [], v = new Vector() this.points.forEach(function (point) &#123; v.x = point.x v.y = point.y scalars.push(v.dotProduct(axis)) &#125;) return new Projection(Math.min.apply(Math, scalars), Math.max,apply(Math, scalars))&#125; 圆形与多边形之间的碰撞检测由于圆形可近似地看成一个有无数条边的正多边形，而我们不可能按照这些边一一进行投影与测试。我们只需将圆形投射到一条投影轴上即可，这条轴就是圆心与多边形顶点中最近的一点的连线，如图所示： 因此，该投影轴和多边形自身的投影轴就组成了一组待检测的投影轴了。 而对于圆形与圆形之间的碰撞检测依然是最初的两圆心距离是否小于两半径之和。 分离轴定理的整体代码实现，可查看以下案例： See the Pen SeparatingAxisTheorem by Jc (@JChehe) on CodePen. 优点： 精确 缺点： 不适用于凹多边形 适用案例： 任意凸多边形和圆形。 更多关于分离轴定理的资料： Separating Axis Theorem (SAT) explanation Collision detection and response Collision detection Using the Separating Axis Theorem SAT (Separating Axis Theorem) Separation of Axis Theorem (SAT) for Collision Detection 延伸：最小平移向量（MIT）通常来说，如果碰撞之后，相撞的双方依然存在，那么就需要将两者分开。分开之后，可以使原来相撞的两物体彼此弹开，也可以让他们黏在一起，还可以根据具体需要来实现其他行为。不过首先要做的是，还是将两者分开，这就需要用到最小平移向量（Minimum Translation Vector, MIT）。 碰撞性能优化若每个周期都需要对全部物体进行两两判断，会造成浪费（因为有些物体分布在不同区域，根本不会发生碰撞）。所以，大部分游戏都会将碰撞分为两个阶段：粗略和精细（broad/narrow）。 粗略阶段（Broad Phase）Broad phase 能为你提供有可能碰撞的实体列表。这可通过一些特殊的数据结构实现，它们能为你提供信息：实体存在哪里和哪些实体在其周围。这些数据结构可以是：四叉树（Quad Trees）、R树（R-Trees）或空间哈希映射（Spatial Hashmap）等。 读者若感兴趣，可以自行查阅相关信息。 精细阶段（Narrow Phase）当你有了较小的实体列表，你可以利用精细阶段的算法（如上述讲述的碰撞算法）得到一个确切的答案（是否发生碰撞）。 最后碰撞检测有多种，选择合适最重要。 完！ 参考资料 MDN：2D collision detection 《HTML5 Canvas 核心技术：图形、动画与游戏开发》 Circular Collision Detection Circle and Rotated Rectangle Collision Detection 推导坐标旋转公式","pubDate":"Thu, 16 Feb 2017 10:00:00 GMT","guid":"https://aotu.io/notes/2017/02/16/2d-collision-detection/","category":"Web开发"},{"title":"探讨判断横竖屏的最佳实现","link":"https://aotu.io/notes/2017/01/31/detect-orientation/","description":"在移动端，判断横竖屏的场景并不少见，比如根据横竖屏以不同的样式来适配，抑或是提醒用户切换为竖屏以保持良好的用户体验。判断横竖屏的实现方法多种多样，本文就此来探讨下目前有哪些实现方法以及其中的优缺点。 CSS Media Queries通过媒体查询的方式，我们可以通过以下方法来实现根据横竖屏不同的情况来适配样式： 1.内联样式1234567@media screen and (orientation:portrait) &#123; //竖屏&#125;@media screen and (orientation:landscape) &#123; //横屏&#125; 2.外联样式12345&lt;!-- 竖屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:portrait)\" href=\"...\" /&gt;&lt;!-- 横屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:landscape)\" href=\"...\" /&gt; window.matchMedia()除此之外，CSS Object Model（CSSOM）Views 规范增加了对 JavaScript 操作 CSS Media Queries 的原生支持，它在 window 对象下增加了 matchMedia() 方法，让我们能够通过脚本的方式来实现媒体查询。 window.matchMedia() 方法接受一个 Media Queries 语句的字符串作为参数，返回一个 MediaQueryList 对象。该对象有 media 和 matches 两个属性： media：返回所查询的 Media Queries 语句字符串 matches：返回一个布尔值，表示当前环境是否匹配查询语句 同时，它还包含了两个方法，用来监听事件： addListener(callback)：绑定回调 callback 函数 removeListener(callback)：注销回调 callback 函数 那么，通过 window.matchMedia() 的方法，我们可以这样判断横竖屏： 12345678910var mql = window.matchMedia(\"(orientation: portrait)\");function onMatchMeidaChange(mql)&#123; if(mql.matches) &#123; // 竖屏 &#125;else &#123; // 横屏 &#125;&#125;onMatchMeidaChange(mql);mql.addListener(onMatchMeidaChange); 通过Can I Use - matchMeida可以知道，该API在移动端得到良好的支持，并无兼容性问题。 window.innerHeight/window.innerWidth The ‘orientation’ media feature is ‘portrait’ when the value of the ‘height’ media feature is greater than or equal to the value of the ‘width’ media feature. Otherwise ‘orientation’ is ‘landscape’.—— CSS/Mediaqueries/orientation 在 CSS Media Queries 中，Orientation 属性有两个值： portrait，指的是当 height 大于等于 width 的情况 landscape，指的是当 height 小于 width 的情况 所以，还有一种最为常见的方法是通过比较页面的宽高，当页面的高大于等于宽时则认为是竖屏，反之则为横屏。 123456789function detectOrient()&#123; if(window.innerHeight &gt;= window.innerWidth) &#123; // 竖屏 &#125;else &#123; // 横屏 &#125;&#125;detectOrient();window.addEventListener('resize',detectOrient); window.orientation在 iOS 平台以及大部分 Android 手机都有支持 window.orientation 这个属性，它返回一个与默认屏幕方向偏离的角度值： 0：代表此时是默认屏幕方向 90：代表顺时针偏离默认屏幕方向90度 -90：代表逆时针偏离默认屏幕方向90度 180：代表偏离默认屏幕方向180度 在 iOS 的开发者文档（iOS Developer Library - Handling Orientation Events）是这样明确定义的： 1234567891011121314151617switch(window.orientation) &#123; case 0: displayStr += \"Portrait\"; break; case -90: displayStr += \"Landscape (right, screen turned clockwise)\"; break; case 90: displayStr += \"Landscape (left, screen turned counterclockwise)\"; break; case 180: displayStr += \"Portrait (upside-down portrait)\"; break;&#125; 也就是如下图所示： （图来自William Malone - DETECT IOS DEVICE ORIENTATION WITH JAVASCRIPT） 在实际应用中，对于 iPhone 和大部分 Android 是没有180度的手机竖屏翻转的情况的，但是 iPad 是存在的。所以，简化下代码，我们可以绑定orientationchange事件来判断横竖屏： 123456789function detectOrient()&#123; if (Math.abs(window.orientation) === 90) &#123; // 横屏 &#125; else &#123; // 竖屏 &#125;&#125;detectOrient();window.addEventListener('orientationchange',detectOrient); 影响判断的问题所在1.对window.orientation属性值的不一致在 iOS 平台，对 window.orientation 属性值是无异议的，规范当中有明确规定每个值对应的情况。但是对于 Android 平台，就有不一致的特殊情况出现。 A misconception about window.orientation中作者 Matthew Gifford 就有提到部分 Android 机型(该文章中测试用的 Toshiba Thrive 机型)返回的情况是与期望情况是相反的；除此之外，在 StackOverflow 上也有反馈过这样的问题（例如，window.orientation returns different values in iOS and Android中提到的 Samsung Tab 2 机型）。 其实，Matthew Gifford 认为这并不是 BUG（笔者也认同），按照Compatibility Standard - 4.2 window.orientation API规范中的定义，0 值指的是 natural 、 default 的屏幕方向，所以如果生厂商对 natural 、 default 状态是用户应当手持设备方向为横屏，那么 0 值对应为 landscape 的横屏方向了。针对这种不一致情况的出现，对于追求完美的开发者来说，通过 window.orientation 的方法来判断横竖屏则变得有点不可靠的。 2.软键盘的弹出是否除了 window.orientation 的其它方法都是可靠的呢？然而，实际上是事与愿违的。在 Android 下，如果页面中出现软键盘弹出的情况（存在有 Input 的元素）时，页面有时会因为软键盘的弹出而导致页面回缩，即页面的宽度（竖屏时）或者高度（横屏时）被改变。无论是 CSS Media Queries 还是 window.matchMedia() 方法，还是根据 window.innerWidth 、window.innerHeight的页面宽高比对方法来实现的横竖屏判断方法，都会因此受到影响，出现判断失误的情况（ Samsung SCH-i699 机型，在竖屏时由于软键盘弹出导致页面高度小于宽度，被错误地判定为横屏）。所以，在这样的情况下，这几种方式也变得不可靠。 探讨最佳实现方式本着核心的原则——具体情况具体解决来讨论。 如果你没有遇上以上两个问题所在，恭喜你！上面所提到的方法都可以被应用，选择你最为喜欢的方法就好。 但是如果想要避免以上两个问题所在，有没有更好的办法呢？ 经过实际情况的研究，针对开发环境兼容的情况（ iOS 与 Android 下的微信内置浏览器与原生浏览器）来说，屏幕分辨率是不会改变的，那么我们可以尝试比对页面宽高和屏幕分辨率来判断横竖屏。 需要注意的是，微信内置浏览器页面宽度不包括顶栏部分的，而 Android 和 iOS 的原生浏览器都是带有底栏或顶栏兼有的，如下图所示。 （图为 iPhone 6s 下的微信内置浏览器与原生浏览器截图） 那么，我们可以确定为： 假如屏幕分辨率固定值为：screen.width 和 screen.height（需要注意，这里很重要的一点是：在移动端，屏幕翻转时，screen.width 和 screen.height 的值依然是不变的后面有补充修正，可以直接跳到下一个章节阅读） 若获取 当前页面的宽（document.documentElement.clientWidth），等于屏幕分辨率的宽(screen.width)，则可认定当前属于竖屏。 （图为以 iPhone 6s 竖屏下的微信内置浏览器为例的截图） 若获取 当前页面的宽（document.documentElement.clientWidth），等于屏幕分辨率的高(screen.height)，则可认定当前属于横屏。 （图为以 iPhone 6s 横屏下的微信内置浏览器为例的截图） 如此，对应的代码为： 1234567891011121314151617181920212223242526272829function detectOrient() &#123; var storage = localStorage; var data = storage.getItem('J-recordOrientX'); var w = document.documentElement.clientWidth, h = document.documentElement.clientHeight; var _Width = 0, _Height = 0; if(!data) &#123; _Width = window.screen.width; _Height = window.screen.height; storage.setItem('J-recordOrientX',_Width + ',' + _Height); &#125;else &#123; var str = data.split(','); _Width = str[0]; _Height = str[1]; &#125; if(w == _Width) &#123; // 竖屏 return; &#125; if(w == _Height)&#123; // 横屏 return; &#125;&#125;detectOrient();window.addEventListener('resize',detectOrient); 以上是笔者拙劣的见解，如果你有更好的办法解决，欢迎来分享！ 今后的发展目前，W3C 引入Screen Orientation API，该标准能够帮助 Web 应用获得屏幕方向的状态，在状态改变时获得通知，并能够从应用程序中将屏幕状态锁定到特定状态。但截止目前，该标准仍在 W3C 草案阶段。在移动端，它在 Android 和 iOS 平台上仍未得到支持，仅仅在 Chrome for Android 39 版本及以上才得到实现，所以对目前的开发来说意义不大。只能期待它能够尽快通过并得到广泛支持，这样的检测屏幕方向的问题就能够得到规范化的解决。 20170425更新感谢各位读者的反馈，笔者的自测确实是没有覆盖全面，有些读者反馈的以下几点问题确实存在：1.在 华为P9 的微信（6.5.4）、华为荣耀的微信（6.5.7）和 Chrome 浏览器上，screen.width 与 screen.height 均会随着横竖屏的切换而变。2.另外，笔者也发现在移动端还有一点很重要的点会影响到 document.documentElement.clientWidth/clientHeight 的值 —— Meta Viewport的设置。3.在微信内（其他移动浏览器也会），会多次触发resize事件。 然而，以上三个问题都是不影响本文所提出的方法的核心思想，而只需要将方法进行bug的修正即可。这里先丢出体验地址，其中，修正后的源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 判断横竖屏var utils = &#123; debounce: function(func,delay)&#123; var timer = null; return function()&#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; func.apply(context,args); &#125;,delay); &#125; &#125;&#125;var detectRes = document.getElementById('J_detectRes');var detectData = document.getElementById('J_detectData');function detectOrient() &#123; var storage = localStorage; // 不一定要使用localStorage，其他存储数据的手段都可以 var data = storage.getItem('J-recordOrientX'); var cw = document.documentElement.clientWidth; var _Width = 0, _Height = 0; if(!data) &#123; sw = window.screen.width; sh = window.screen.height; // 2.在某些机型（如华为P9）下出现 srceen.width/height 值交换，所以进行大小值比较判断 _Width = sw &lt; sh ? sw : sh; _Height = sw &gt;= sh ? sw : sh; storage.setItem('J-recordOrientX',_Width + ',' + _Height); &#125;else &#123; var str = data.split(','); _Width = str[0]; _Height = str[1]; &#125; if(cw == _Width) &#123; // 竖屏 return; &#125; if(cw == _Height)&#123; // 横屏 return; &#125;&#125;// 3.函数去抖处理window.onresize = utils.debounce(detectOrient,300);detectOrient(); 然后，下面则讲诉如何针对性逐一突破。 1.横竖屏切换时，screen.width与screen.height的值可能会改变随着横竖屏幕的切换，screen.width与screen.height在大部分机型上会维持不变，而在一些机型上如@Jc、@百思不得姐夫提出的华为 P9 微信内置浏览器(6.5.4版本)、Chrome桌面端浏览器模拟器中会出现值交换的现象。 例如，在Chome上 iPhone 6 模拟器中，竖屏时screen.width与screen.height等于375px、667px，而横屏时，sreen.width与screen.height等于 667px 、 375px，两者属性值出现了值交换现象。 这个问题很容易解决，虽然出现了值交换，但是值大小还是不变的，那么我们可以先通过比较大小来判断出属性值较小的是screen.width，而属性值较大的是screen.height，然后再用来与document.documentElement.clientWidth/clientHeight进行比较，从而判断出横竖屏。 2.Meta Viewport的设置会影响document.documentElement.clientWidth/clientHeightPeter-Paul Koch 的《两个 Viewport 的故事》的一文中提出的关于 Viewport 的理论被认为是业界的主流论调，它指出 Layout Viewport 的尺寸可以通过document.documentElement.clientWidth/clientHeight进行度量。而通过设置 Meta Viewport （也就是 viewport meta 标签）是可以改变 Layout Viewport 的尺寸。 所以，Meta Viewport的属性设置如何是会影响到document.documentElement.clientWidth/clientHeight的值，这就是一部分读者迷惑到”为什么会我测量document.documentElement.clientWidth/clientHeight的值与screen.width/height的值不相同？“的原因所在。 因此，在这里也补充一点，在笔者提出的方法中，有个忘记跟大家说明的前提——页面设置了以下属性以保证页面的适配： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;\" /&gt; 这句语句的设置就保证了页面是始终适配屏幕的，在横竖屏切换的场景中document.documentElement.clientWidth/clientHeight必然与screen.width/height其中一值相等，并且这也是本文提出的横竖屏检测方法的核心。 3.resize事件的多次触发笔者是通过绑定监听resize事件来响应执行横竖屏检测方法的，而在实际应用中确实出现了resize事件触发两次的情况。 虽然并没有影响到事件的判断结果，但是这也算个值得优化的点，而且问题也不大，我们只要通过函数去抖（ Debounce Function ) 办法来进行简单的解决就好。 123456789101112131415// 函数去抖的简单封装var utils = &#123; debounce: function(func,delay)&#123; var timer = null; return function()&#123; var context = this, args = arguments; clearTimeout(timer); timer = setTimeout(function()&#123; func.apply(context,args); &#125;,delay); &#125; &#125;, ...&#125; 参考文档 A misconception about window.orientation Trouble with web browser orientation Compatibility Standard - 4.2 window.orientation API","pubDate":"Tue, 31 Jan 2017 01:27:00 GMT","guid":"https://aotu.io/notes/2017/01/31/detect-orientation/","category":"Web开发"},{"title":"使用 Snap.svg 制作动画","link":"https://aotu.io/notes/2017/01/22/snapsvg/","description":"一、Snap.svg是什么从主要功能上说，Snap.svg.js 是一个操纵 SVG 节点/制作 SVG 动画的框架，简单点理解可以看下面文字： Snap.svg 是一个可以使你操纵 SVG 资源和 jQuery 操作 DOM 一样简单的类库 ——译自官网 拿 Snap.svg (下文简称 Snap ) 和 jQuery (下文简称 JQ ) 来做对比最合适不过，很可能作者也是参考了 JQ 的 API 设计，那么它们的相似程度有多高呢？请看下面的对比表： / context(上下文) 选择器 事件绑定 节点操作 属性操作 链式写法 Snap svg Snap.select(‘circle’) el.click(…)/el.touchend(…) after()/remove()/append() attr() svg.paper.circle(50,50,40).attr({fill:”#f00”}); JQ document jQuery(‘div’) el.click(…) after()/remove()/append() attr() elem.addClass(‘hide’).remove(); 在 JQ 中，可操作的最外层 DOM 边界是 document 。而在 Snap 的概念里，可操作的最外层的节点是 svg ，svg 节点的选择、事件绑定都需要在这个上下文里完成。 在上面的对比图可以看出很多 JQ 的影子，无论是选择器、事件绑定、节点操作等等，都是非常的类似 JQ ，有 JQ 基础的同学基本可以半天掌握 Snap 的全部 API。 二、Snap 的代码结构 笔者根据 Snap 的 API 制作了上面的图表，并且简单标注了注释方便大家理解，可以重点关注一下 Element 和 Paper 这两个类。 1. Element这个部分是节点操作相关的方法集，也是该类库最基础的部分。 1234// 选择节点var svg = Snap('#svg');svg.select('circle'); // 选择svg.select('.rect_01'); // 选择 12345// 事件绑定var svg = Snap('#svg');svg.select('circle').click(function() &#123; // do something&#125;); 更多方法请参考文后 API 资料。 2. Paper这部分是画图相关的方法集，这是几乎每个动画框架都有的部分，类似于createjs的Graphics。 SVG 有6种基本图形：矩形、圆形 、椭圆、线条、折线、多边形。还有另外一种：路径(path)，path 是最复杂的一种绘图方式，它可以绘制复杂的图形——当然6种基本图形也不在话下。而关于基本图像与 path 之间的转换，可以参考本站的另外一篇文章：聊聊 SVG 基本形状转换那些事。 Paper 方法集主要可以绘制6种基本图形（节点），以及文本（节点）、图片（节点）、渐变等。 1234567891011// 画一个圆var svg = Snap('#svg');svg.paper.circle(&#123; cx: 100, cy: 100, r: 50, fill: '#f00'&#125;);// 创建一张图片svg.paper.image('url.jpg', 0, 400, 300, 300); 3. Snap 工具方法Snap下有不少实用工具，比如 Snap.ajax、Snap.format模板、颜色格式转换和插件方法等。 123456// 扩展Snap，为其添加插件方法Snap.plugin(function (Snap, Element, Paper, global, Fragment) &#123; Snap.newmethod = function () &#123;&#125;; Element.prototype.newmethod = function () &#123;&#125;; Paper.prototype.newmethod = function () &#123;&#125;;&#125;); 三、用 Snap 制作动画1. 制作动画的方法Snap 的做动画主要有两种方式： 使用 Element 里的 animate 方法，Element.animate(attrs, duration, [easing], [callback]) 使用 Snap 的静态方法，Snap.animate(from, to, setter, duration, [easing], [callback])，这种方法更通用也更强大，指定开始结束值，setter里面可以放置多个节点的动画。 样例：演示Element.animate方法的使用。预览地址点此 12345678910111213141516// 动画样例1var svg = Snap('#svg');svg.select('circle').animate(&#123;r: 100&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;);// 动画样例2var svg = Snap('#svg');var circle = svg.select('circle');var rect = svg.select('rect');Snap.animate(0, 100, function(val) &#123; circle.attr(&#123;r: val&#125;); rect.attr(&#123;x: val&#125;);&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 2. 动画的属性在 Snap 中，可作为动画的属性有哪些呢？笔者大致分为了几类： 简单数值类，如坐标、宽高、opacity、大部分 Paper API 可配置的属性值，甚至滤镜相关的属性。如{x:100} -&gt; {x:200}, {width:0} -&gt; {width:100} path 相关动画，如d属性（变形动画）、描边动画、路径跟随动画 matrix 类，放大缩小、位移、旋转等，和 CSS 的 transform 类似 颜色类，颜色变换动画，如 fill、stroke 属性，如{fill:’#f00’} -&gt; {fill:’#f0f’} 样例：颜色变换动画，预览地址点此 123456// 动画样例，颜色变化动画var svg = Snap('#svg');var circle = svg.paper.circle(&#123;cx: 100, cy: 100, r: 50, fill: '#f00'&#125;);circle.animate(&#123;fill: '#00f'&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 四、path &amp; matrix 动画详解这个小节重点会讲上面第2小节提到的 path、matrix 相关动画方式，以及和 CSS 的 transform 动画的异同。 1. path 动画1). path 变形动画这种类型的动画非常强大。上文已提到基本图形和 path 是可以相互转换的，所以基本图形间的变形动画也是成立的。不仅如此，更复杂的 path 图形，比如波浪、房子、汽车、白云、小icon等，都是可以互相变形。 path 的d属性在 Snap 的解析规则里可以通过一系列的数学运算，动画中通过插值，达到最终态的d值，不过中间的插值计算我们无法干预。 123456789101112// 开始态var path = svg.paper.path(&#123;d: 'M0.500,65.500 C18.680,33.758 45.141,-6.797 72.500,2.500 C99.859,11.797 72.148,59.027 79.500,98.500 C86.852,137.973 117.668,128.914 138.500,59.500 C159.332,-9.914 246.500,59.500 246.500,59.500 C273.181,117.750 137.350,184.417 225.500,173.500 C351.137,157.940 155.369,160.617 162.500,86.500 C165.180,58.645 237.169,-2.418 283.500,2.500 C357.654,10.371 363.758,80.355 364.500,109.500',stroke:'#f00', fill: 'rgba(0,0,0,0)'&#125;);setTimeout(function() &#123; // 终止态：曲线变直 // path.animate(&#123;d: 'M1,100 L350,100'&#125;, 1000, mina.easeout(), function() &#123; // console.log('animation end'); // &#125;); // 终止态：心形 path.animate(&#123;d: 'M114.500,58.500 C106.230,58.751 23.907,-37.262 5.500,21.500 C-26.759,124.483 111.761,221.360 119.500,219.500 C154.464,211.096 201.234,149.580 220.500,104.500 C250.260,34.864 220.892,7.159 194.500,1.500 C160.455,-5.800 122.344,58.262 114.500,58.500 Z'&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end'); &#125;);&#125;, 1000); 样例：曲线变直线，预览地址点此 样例：曲线变心形，预览地址点此 2). path 描边动画这种动画主要用的是 svg 的 stroke-dasharray、stroke-dashoffset 属性，这中动画方式在本站的另外一篇文章有详细介绍，这里不再赘述：三看 SVG Web 动效 样例：简单曲线描边动画12345678910111213var path = svg.paper.path(&#123;d: 'M0.500,65.500 C18.680,33.758 45.141,-6.797 72.500,2.500 C99.859,11.797 72.148,59.027 79.500,98.500 C86.852,137.973 117.668,128.914 138.500,59.500 C159.332,-9.914 246.500,59.500 246.500,59.500 C273.181,117.750 137.350,184.417 225.500,173.500 C351.137,157.940 155.369,160.617 162.500,86.500 C165.180,58.645 237.169,-2.418 283.500,2.500 C357.654,10.371 363.758,80.355 364.500,109.500', stroke:'#f00', fill: 'rgba(0,0,0,0)'&#125;);var length = Snap.path.getTotalLength(path);path.attr(&#123; 'stroke-dashoffset': length, 'stroke-dasharray': length // 用Snap的API计算复杂的path长度&#125;);Snap.animate(length, 0, function(val) &#123; path.attr(&#123; 'stroke-dashoffset': val &#125;);&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 或者用CSS实现：12345678@keyframes demo4 &#123; 100% &#123; stroke-dashoffset: 0 &#125;&#125;.demo4 &#123; animation: demo4 1s ease-out infinite both;&#125; 样例：花纹描边。这是codepen上一个复杂的例子——复杂花纹的描边动画，预览地址点此： 3). path 路径跟随动画这种动画是指一个 svg 节点（基本图形、文本、图片等）沿着轨迹移动的动画，主要适用于模拟交通工具航行轨迹、粒子散开轨迹等。 这种动画的关键之处在于要知道 path 的长度与坐标之间的对应关系，Snap 提供了可供获取path的长度以及根据长度获取位置坐标的 API。结合上面的 Snap.animate 方法，路径跟随动画的制作会变得非常简单。 样例：跟随曲线运动的小飞机，预览地址点此： 12345678910var length = Snap.path.getTotalLength(path); // 获取path的长度Snap.animate(0, length, function(val) &#123; var point = Snap.path.getPointAtLength(path, val); // 根据path长度变化获取坐标 var m = new Snap.Matrix(); m.translate(point.x, point.y); m.rotate(point.alpha-90); // 使飞机总是朝着曲线方向。point.alpha：点的切线和水平线形成的夹角 plane.transform(m);&#125;, 30000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 样例：双12开场动画，这是笔者去年双12做的一个路径跟随动画效果，预览地址点此： 另外，用新的 CSS 属性 motion-path 也可以实现类似效果，但目前支持程度堪忧，只有 PC 的 chrome 以及 Opera、最新的X5内核手机浏览器 支持情况较好。 12345678910111213@keyframes demo5 &#123; 0% &#123; motion-offset: 0; &#125; 100% &#123; motion-offset: 100%; &#125;&#125;.demo5 &#123; motion-path: path(\"M221.712,180.442C237.176,177.728,279.348,178.094,261,152c-18.742-26.654-48.543-28.207-63-22-14.981,6.431-34.763,6.357-34,40s66.09,74.162,88,68,60.358-23.742,67-49,14.211-59.957-27-81S163.688,88.664,153,98c-7.828,6.838-32.045,22.952-32,64,0.039,35.491,7.878,62.872,14,78s52.737,39.557,73,41,58.638,16.552,105-7c44.249-22.478,75.073-94.409,55-164C349.768,46.792,217.142,54.519,200,55S104.613,66.128,78,111c-16.922,28.532-16.5,96.616,1,134,14.482,30.932,51.88,58.52,68,64,39.988,13.593,100.081,21.615,129,17\"); motion-rotation: auto 90deg; // 使飞机方向始终朝着曲线 animation: demo5 10s linear infinite both;&#125; 预览地址点此（请在最新版 chrome、Opera 或最新的X5内核手机浏览器查看） 2. matrix动画Snap 的 matrix 动画包含各位熟悉的 translate/scale/rotate/skew 动画，原理和 CSS 的 transform 也几乎一致。 1) matrix简单位移动画，预览地址点此： 12345678910111213// 简单位移动画var rect = svg.paper.rect(&#123;x: 100, y: 100, width: 50, height: 30, fill: '#f00'&#125;);var anim = function() &#123; Snap.animate(0, 150, function(val) &#123; var m = new Snap.Matrix(); m.translate(val, 0); // translate位移API rect.transform(m); // 在rect节点应用matrix &#125;, 1000, mina.easeout(), function() &#123; console.log('animation end'); setTimeout(anim, 300); &#125;);&#125;anim(); 2) matrix位移、旋转复合动画，预览地址点此： 12345678910111213141516171819202122232425// 位移、旋转复合动画var rect = svg.paper.rect(&#123;x: 10, y: 100, width: 50, height: 30, fill: '#f00'&#125;);var g = svg.paper.group(rect); // 创建了一个分组节点g作为位移动画节点var anim_rotate = function() &#123; // 节点旋转部分 Snap.animate(0, 250, function(val) &#123; var m = new Snap.Matrix(); m.rotate((val/250)*360, 10+25, 100+15); // 注意，后面两位数是旋转中心点，属于绝对坐标，svg里节点的变换中心都是绝对坐标，和CSS的transform-origin取值不太一样 rect.transform(m); &#125;, 500, mina.easeout(), function() &#123; console.log('animation end'); anim_rotate(); &#125;);&#125;;anim_rotate();var anim_move = function() &#123; // 节点位移部分 Snap.animate(0, 250, function(val) &#123; var m = new Snap.Matrix(); m.translate(val, 0); g.transform(m); &#125;, 2000, mina.easeout(), function() &#123; console.log('animation end'); anim_move(); &#125;);&#125;;anim_move(); 上面两个动画用 CSS 的方式实现代码如下：12345678910111213141516171819202122232425262728@keyframes demo6 &#123; 100% &#123; transform: translate3d(250px, 0, 0); &#125;&#125;// 简单位移动画CSS版.demo6 &#123; animation: demo6 2s linear infinite both;&#125;@keyframes demo7_rotate &#123; 100% &#123; transform: rotate(360deg); &#125;&#125;@keyframes demo7_move &#123; 100% &#123; transform: translate3d(250px, 0, 0); &#125;&#125;// 旋转、位移符合动画CSS版.demo7 &#123; animation: demo7_move 2s linear infinite both; rect &#123; transform-origin: 35px 115px; animation: demo7_rotate .5s linear infinite both; &#125;&#125; 简单位移动画CSS版预览点此；旋转、位移符合动画CSS版预览点此。 五、几个兼容性说明及建议这部分会说一下笔者在开发过程中遇到的一些兼容性问题以及使用建议。当然还会有更多的笔者没遇到的问题，欢迎各位看官多多评论交流，不吝赐教。 总的来说，Snap 的 API 兼容性不错，官网声称兼容 IE9 及以上、Safari、Chrome、Firefox、Opera；而移动设备方面，经笔者测试 iOS、安卓 X5 内核、安卓原生浏览器兼容性都不错，文中的例子除了特殊说明外的都可以执行 作用于 svg 节点的 CSS transform 动画在安卓原生浏览器下兼容性不好， X5 则正常 在 iOS7 和 8 下 innerHTML 方法不能用于 svg 里 安卓原生浏览器绘制 svg 图形很可能会产生渲染模糊的现象（如下图），在 svg 里加上一个 text 节点即可神奇的修复 这样的节点 &lt;text&gt;a&lt;/text&gt; 即可修复模糊的问题，但不能 display:none 隐藏 在使用建议方面： 一般来说，transform 动画可以优先使用 CSS 的方式实现，但如果需要复杂的分段控制或者更好的兼容性，可以试试 Snap 的 transform&amp;matrix 方式 Snap 的有些动画需要大量计算，虽然 svg 里的节点属于“绝对定位”，动画时一般不会引起重排（参考下图），但在移动设备上也要注意动画元素不宜过多。以 image 动画为例， 经笔者测试，150x150 左右的图片动画节点控制在 10 个左右基本能达到大部分机型的性能要求 滤镜类属性在移动设备上不宜做动画 小飞机动画在 chrome 的渲染层边界图： 橙色边为 svg 的边界（即渲染层，为了便于查看 svg 节点经过了 transform:rotateY(30deg) ；绿色为重绘部分。可以看出 svg 里的动画元素只会引起重绘，而里面的节点用 translateZ 也并不会新开一个渲染层。 六、参考资料Snap.svg官网 Web动画API教程5：可爱的运动路径（Motion Path) 张鑫旭：Snap.svg API中文文档兼demo实例页面","pubDate":"Sun, 22 Jan 2017 15:55:00 GMT","guid":"https://aotu.io/notes/2017/01/22/snapsvg/","category":"Web开发"},{"title":"sass-svg 一个内联 SVG 的 SASS 库","link":"https://aotu.io/notes/2017/01/19/sass-svg/","description":"一、CSS内联 SVG一直觉得 内联 SVG 是 HTML 的延伸，但是内联 SVG 往往会造成HTML结构的臃肿。于是笔者尝试着把 SVG 移植到 CSS 中，如下： 12345background: url(&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"393.969\" height=\"28.219\" viewBox=\"0 0 393.969 28.219\"&gt; &lt;path d=\"M0.969,11.313 C-20.207,69.711 314.183,-47.984 393.969,24.312 \"/&gt;&lt;/svg&gt;) 目前（2017.01.12）而言，没有任何浏览器的 CSS 支持内联 SVG 代码，所以上述的代码是一段非法的 css。尽管任何浏览器的 CSS 都不支持内联 SVG 代码，但是所有的现代浏览都是支持内联 SVG 文件，如下： 1background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA3NTAgNDAwIj4gCQkJPHBhdGggZD0iTTAsMCBMNzUwLDAgTDc1MCw0MDAgTDM4OCw0MDAgTDM3NSwzODcsIEwzNjIsNDAwIEwwLDQwMFoiIGZpbGw9IiMwZjAiPjwvcGF0aD4gCQk8L3N2Zz4=); 内联 SVG 文件即 Data-URI。 二、Data-URI 简介 A new URL scheme, “data”, is defined. It allows inclusion of small data items as “immediate” data, as if it had been included externally.摘录自：https://tools.ietf.org/html/rfc2397 简单地说，Data-URI 是一种将小文件转换成直接字面数据的方案(scheme)。Data-URI 的语法如下： 1data:[&lt;media type&gt;][;base64],&lt;data&gt; &lt;media type&gt;: 即指定嵌入数据的 MIME，对于 PNG 的图片，其格式是：image/png，如果没有指定，默认是：text/plain；[;base64]: base64 编码扩展，非必选项。如果没指定 base64 编码扩展，后面的 &lt;data&gt; 将使用 URL编码（即百分号编码）。&lt;data&gt;: 编码后的小文件数据。图片文件则是对二进制文件流进行编码，文本文件则是对文本进行编码。 附注：Data-URI 是正式术语，日常中更常用的名字是 Base64。 三、sass-svgsass-svg 是一个将 SVG 代码转化为 Data-URI 的 Sass 库。了解 Data-URI 后，sass-svg 的作用其实就是把 SVG 进行编码的过程。 1. URL编码在 JS 中可以使用 encodeURI 或 encodeURIComponent 来对字符进行 URL 编码，而 Sass 并没有相对就的编码方法。了解一下 URL编码的知识点： URL 编码的原理：ASCII 字符 = % + 两位 ASCII 码（十六进制）。例如，字符 a 对应的 ASCII 码为 0x61，那么 URL 编码后得到 %61。 「rfc3986」规定 URL 只允许英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及保留字符(! * &#39; ( ) ; : @ &amp; = + $ , / ? # [ ])。 尽管 Sass 不提供获取 ASCII 码的函数，但创建一张 ASCII 字符 与 ASCII 码 的对照表(map) 却是廉价的。标准的 ASCII 字符一共是 128 个，剔除 rfc3986 规定的不需要编码的字符（84个），再把扣除一些控制符，实际上需要编码的字符只有 13 个，如下： 12345678910111213141516// ascii 与 16进制对照表$asciiHexMap: ( \" \": \"%09\", \" \": \"%20\", \"\\\"\": \"%22\", \"%\": \"%25\", \"/\": \"%2f\", \"&lt;\": \"%3c\", \"&gt;\": \"%3e\", \"\\\\\": \"%5c\", \"^\": \"%5e\", \"`\": \"%60\", \"&#123;\": \"%7b\", \"|\": \"%7c\", \"&#125;\": \"%7d\"); 实现 URL 编码要求 sass 版本3.3以上，因为需要用到三个内置函数：str_index、str_slice 和 str_insert。 实现 URL 编码的过程不详述，笔者已经将相关代码放到 GIT 仓库，有兴趣的同学可以访问 「sass-svg」。 注意：本文所描述的编码仅针对 US-ASCII 字符集。中文或其它字符不讨论 2. Base64 编码Base64 使用 US-ASCII 子集的64个字符，即大小写的26个英文字母，0～9，＋，/。如下： 12345678'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H','I', 'J', 'K', 'L', 'M', 'N', 'O', 'P','Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f','g', 'h', 'i', 'j', 'k', 'l', 'm', 'n','o', 'p', 'q', 'r', 's', 't', 'u', 'v','w', 'x', 'y', 'z', '0', '1', '2', '3','4', '5', '6', '7', '8', '9', '+', '/' Base64 编码总是基于3个字符，每个字符用8位二进制表示，因此一共24位，再分为4四组，每组6位表示一个 Base64 的值。如果不足3个字符，仍将每个字符对应的二进制串起，再按每组6位表示一个 Base64的值，不足6位的用 0补全，最后生成的 Base64 码不足4位用=补全。 举个例子来感受一下： 与 URL编码相似，SASS 无法直接获取 ASCII 字符对应的二进制，也无法将6位二进制转成 Base64 码。这意味着需要手动创建两张对照表(map)。如下： 123456789101112131415161718192021222324252627// ascii字符 与 8位二进制 对照表$asciiMap: ( \" \": \"00001001\", \" \": \"00100000\", \"!\": \"00100001\", \"\\\"\": \"00100010\", \"#\": \"00100011\", \"$\": \"00100100\", \"%\": \"00100101\", \"&amp;\": \"00100110\", \"'\": \"00100111\", \"(\": \"00101000\", \")\": \"00101001\", \"*\": \"00101010\", \"+\": \"00101011\", \",\": \"00101100\", \"-\": \"00101101\", \".\": \"00101110\", \"/\": \"00101111\", \"0\": \"00110000\", \"1\": \"00110001\", \"2\": \"00110010\", \"3\": \"00110011\", \"4\": \"00110100\", \"5\": \"00110101\", \"6\": \"00110110\", \"7\": \"00110111\", \"8\": \"00111000\", \"9\": \"00111001\", \":\": \"00111010\", \";\": \"00111011\", \"&lt;\": \"00111100\", \"=\": \"00111101\", \"&gt;\": \"00111110\", \"?\": \"00111111\", \"@\": \"01000000\", \"A\": \"01000001\", \"B\": \"01000010\", \"C\": \"01000011\", \"D\": \"01000100\", \"E\": \"01000101\", \"F\": \"01000110\", \"G\": \"01000111\", \"H\": \"01001000\", \"I\": \"01001001\", \"J\": \"01001010\", \"K\": \"01001011\", \"L\": \"01001100\", \"M\": \"01001101\", \"N\": \"01001110\", \"O\": \"01001111\", \"P\": \"01010000\", \"Q\": \"01010001\", \"R\": \"01010010\", \"S\": \"01010011\", \"T\": \"01010100\", \"U\": \"01010101\", \"V\": \"01010110\", \"W\": \"01010111\", \"X\": \"01011000\", \"Y\": \"01011001\", \"Z\": \"01011010\", \"[\": \"01011011\", \"\\\\\": \"01011100\", \"]\": \"01011101\", \"^\": \"01011110\", \"_\": \"01011111\", \"`\": \"01100000\", \"a\": \"01100001\", \"b\": \"01100010\", \"c\": \"01100011\", \"d\": \"01100100\", \"e\": \"01100101\", \"f\": \"01100110\", \"g\": \"01100111\", \"h\": \"01101000\", \"i\": \"01101001\", \"j\": \"01101010\", \"k\": \"01101011\", \"l\": \"01101100\", \"m\": \"01101101\", \"n\": \"01101110\", \"o\": \"01101111\", \"p\": \"01110000\", \"q\": \"01110001\", \"r\": \"01110010\", \"s\": \"01110011\", \"t\": \"01110100\", \"u\": \"01110101\", \"v\": \"01110110\", \"w\": \"01110111\", \"x\": \"01111000\", \"y\": \"01111001\", \"z\": \"01111010\", \"&#123;\": \"01111011\", \"|\": \"01111100\", \"&#125;\": \"01111101\", \"~\": \"01111110\"); 123456789101112131415161718192021// 二进制 与 base64 对照表$base64map: ( \"000000\": 'A', \"000001\": 'B', \"000010\": 'C', \"000011\": 'D', \"000100\": 'E', \"000101\": 'F', \"000110\": 'G', \"000111\": 'H', \"001000\": 'I', \"001001\": 'J', \"001010\": 'K', \"001011\": 'L', \"001100\": 'M', \"001101\": 'N', \"001110\": 'O', \"001111\": 'P', \"010000\": 'Q', \"010001\": 'R', \"010010\": 'S', \"010011\": 'T', \"010100\": 'U', \"010101\": 'V', \"010110\": 'W', \"010111\": 'X', \"011000\": 'Y', \"011001\": 'Z', \"011010\": 'a', \"011011\": 'b', \"011100\": 'c', \"011101\": 'd', \"011110\": 'e', \"011111\": 'f', \"100000\": 'g', \"100001\": 'h', \"100010\": 'i', \"100011\": 'j', \"100100\": 'k', \"100101\": 'l', \"100110\": 'm', \"100111\": 'n', \"101000\": 'o', \"101001\": 'p', \"101010\": 'q', \"101011\": 'r', \"101100\": 's', \"101101\": 't', \"101110\": 'u', \"101111\": 'v', \"110000\": 'w', \"110001\": 'x', \"110010\": 'y', \"110011\": 'z', \"110100\": '0', \"110101\": '1', \"110110\": '2', \"110111\": '3', \"111000\": '4', \"111001\": '5', \"111010\": '6', \"111011\": '7', \"111100\": '8', \"111101\": '9', \"111110\": '+', \"111111\": '/', \"======\": '=' // base64占位符); 实现过程不详述。有兴趣可以访问「sass-svg」。 3. sass-svg 的一个实例开头的非法 CSS，通过 sass-svg 可以改写成： 123456// scssbackground: url( sass-svg-base64('&lt;svg viewBox=\"0 0 393.969 28.219\"&gt; &lt;path d=\"M0.969,11.313 C-20.207,69.711 314.183,-47.984 393.969,24.312 \"/&gt; &lt;/svg&gt;')) 通过编译最终会生成： 1background: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzOTMuOTY5IDI4LjIxOSI+IAkJICA8cGF0aCBkPSJNMC45NjksMTEuMzEzIEMtMjAuMjA3LDY5LjcxMSAzMTQuMTgzLC00Ny45ODQgMzkzLjk2OSwyNC4zMTIgIi8+IAkJPC9zdmc+\"); 结语感谢阅读本文。关于 sass-svg 的应用，笔者会有后续文章介绍，如果喜欢本文请关注一下我们『凹凸实验室』的微信公众号：AOTULabs 参考资料 Data URI scheme - Wikipedia RFC 2397 - The “data” URL scheme Uniform Resource Identifier (URI): Generic Syntax Uniform Resource Locators (URL) Base64编码解码算法 Module: Sass::Script::Functions URL编码与解码原理 Base64编码解码算法","pubDate":"Thu, 19 Jan 2017 14:21:44 GMT","guid":"https://aotu.io/notes/2017/01/19/sass-svg/","category":"Web开发"},{"title":"微信小程序跨页面通信解决思路","link":"https://aotu.io/notes/2017/01/19/wxapp-event/","description":"宏观上，微信小程序是由一个个 Page 组成的。有时候我们会遇到一些业务存在耦合的 Page，一个 Page 里某个状态改变后，相关 Page 的状态需要进行更新。而在小程序里，每个 Page 都是一个模块，有着独立的作用域，因此 Page 间需要有一种通信策略。 想象一个业务场景，用户首先进入订单列表页。然后点击其中一个订单，进入到订单详情页。当用户在订单详情页对订单进行操作，例如支付、确认收货等时，该订单的状态就会发生改变。此时需要对上一级的订单列表页中该订单的状态进行更新： 要想更新订单列表页的视图层，就需要调用该 Page 对象的 setData 方法。这里为大家列举三种比较常用的方案： 设置标志位最简单的方法，在订单详情页对订单的操作成功回调中，把一些标志位设置为 true，并设置好参数（标志位和参数可以存在 localStorage 或挂在全局 App 对象下）。然后每次在订单列表页的 onShow 生命周期中，根据这些标志位去判断是否进行更新、更新的参数是什么。 这种处理在业务逻辑比较简单、页面间的耦合度很小时还能凑合，一旦逻辑复杂起来，就需要写很多冗余的代码，并且维护成本会非常高。 流程图： 利用页面栈获取 Page 对象如果订单详情页里能拿到订单列表页的 Page 对象，就能去调用它的 setData 方法。小程序提供了一个方法 getCurrentPages，执行它可以得到当前页面栈的实例，然后再根据页面进栈的顺序我们就能拿到订单列表页的 Page 对象。 然而这种做法的缺点还是耦合度太大，过度依赖页面进栈顺序。一旦在以后的产品迭代中页面顺序发生变化，将很难去维护。 流程图： 上述两种方法都存在着耦合度大、维护困难的问题，而利用发布／订阅模式能很好的实现解耦，下面我们先来了解一下这种设计模式。 发布／订阅模式（最优方案）发布／订阅模式由一个发布者、多个订阅者以及一个调度中心所组成。订阅者们先在调度中心订阅某一事件并注册相应的回调函数，当某一时刻发布者发布了一个事件，调度中心会取出订阅了该事件的订阅者们所注册的回调函数来执行。 在发布／订阅模式中，订阅者和发布者并不需要关心对方的状态，订阅者只管订阅事件并注册回调、发布者只管发布事件，其余一切交给调度中心来调度，从而能实现解耦。 在 app 跨页面通信这个问题上，iOS 端的 Notification Center、安卓端的 EventBus，也是通过这样一种设计模式去解决的，不过微信小程序内部并没有提供这种事件通知机制，所以我们需要手动去实现一个。 我们首先要实现一个 Event 类，它应该含有一个收集回调函数的对象，和提供三个基础方法：on（订阅）、 emit（发布）、 off（注销）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// event.jsclass Event &#123; /** * on 方法把订阅者所想要订阅的事件及相应的回调函数记录在 Event 对象的 _cbs 属性中 */ on (event, fn) &#123; if (typeof fn != \"function\") &#123; console.error('fn must be a function') return &#125; this._cbs = this._cbs || &#123;&#125; ;(this._cbs[event] = this._cbs[event] || []).push(fn) &#125; /** * emit 方法接受一个事件名称参数，在 Event 对象的 _cbs 属性中取出对应的数组，并逐个执行里面的回调函数 */ emit (event) &#123; this._cbs = this._cbs || &#123;&#125; var callbacks = this._cbs[event], args if (callbacks) &#123; callbacks = callbacks.slice(0) args = [].slice.call(arguments, 1) for (var i = 0, len = callbacks.length; i &lt; len; i++) &#123; callbacks[i].apply(null, args) &#125; &#125; &#125; /** * off 方法接受事件名称和当初注册的回调函数作参数，在 Event 对象的 _cbs 属性中删除对应的回调函数。 */ off (event, fn) &#123; this._cbs = this._cbs || &#123;&#125; // all if (!arguments.length) &#123; this._cbs = &#123;&#125; return &#125; var callbacks = this._cbs[event] if (!callbacks) return // remove all handlers if (arguments.length === 1) &#123; delete this._cbs[event] return &#125; // remove specific handler var cb for (var i = 0, len = callbacks.length; i &lt; len; i++) &#123; cb = callbacks[i] if (cb === fn || cb.fn === fn) &#123; callbacks.splice(i, 1) break &#125; &#125; return &#125; &#125; 具体调用方法App 是小程序的实例，在每个 Page 里都能通过执行 getApp 函数获取到它。我们可以把 Event 类的实例挂载在 App 中，方便每个 Page 去调用。 12345678// app.jsconst Event = require('./libs/event')App(&#123; event: new Event(), ...&#125;) 订单列表页在 onLoad 生命周期中订阅 “afterPaySuccess” 事件。 12345678910111213//order_list.jsvar app = getApp()Page(&#123; onLoad: function()&#123; app.event.on('afterPaySuccess',this.afterPaySuccess.bind(this)) &#125;, afterPaySuccess: function(orderId) &#123; ... &#125;, ...&#125;) 在订单详情页支付成功的回调中，发布 “afterPaySuccess” 事件,同时带上订单 id 参数。 1234567891011//order_detail.jsvar app = getApp()Page(&#123; raisePayment: function() &#123; ... app.event.emit('afterPaySuccess', orderId) &#125;, ...&#125;) 所有 Page 的 onUnload 生命周期，必须注销掉之前订阅的事件。注销方法 off 的调用姿势有三种，不过还是建议注销当前 Page 所订阅的事件，而不是注销所有的。 12345678910111213var app = getApp()Page(&#123; onUnload: function()&#123; // remove all app.event.off() // remove all callbacks app.event.off('afterPaySuccess') // remove specific callbacks app.event.off('afterPaySuccess', this.afterPaySuccess) &#125;, ...&#125;) 到此就结束了吗？还没有，按照我们的订阅、注销写法，在注销指定回调函数的时候，其实是永远注销不了的。 完善off方法为了让每个回调函数被调用时的 this 都指向对应的 Page 对象，必须在订阅时对回调函数绑定当前的上下文对象。 1app.event.on('afterPaySuccess',this.afterPaySuccess.bind(this)) 相当于 12345app.event.on('afterPaySuccess', function()&#123; var args = Array.prototype.slice.call(arguments) // fn、that分别为闭包起来的回调函数和page对象 return fn.apply(that, args)&#125;) 正因为 bind 方法会返回这样一个匿名函数，然后这个匿名函数会被加入到回调数组中。因此我们注销指定回调函数的时候，在回调数组中是找不到它的，也就永远无法注销。 为了保持我们原来的 emit 调用方式，我想过直接把 Function.prototype.bind 改写： 123456789Function.prototype.bind = function(that) &#123; var fn = this var cb = function()&#123; var args = Array.prototype.slice.call(arguments) return fn.apply(that, args) &#125; cb.fn = this return cb&#125; 然后再稍微修改一下 off 方法里的判断条件 1234567// remove specific callbacks...if (cb === fn || cb.fn === fn) &#123; callbacks.splice(i, 1) break&#125;... 在浏览器环境这种做法是可行的，但是在小程序侧则是失败的。因为我们定义的这些 function 在小程序里并不是 Function 的实例，那无论我怎样修改 Function 的 prototype 属性，function 并不会继承到。原因是小程序把 Function 给改写了： 1234//consoleFunction.toString()// \"function ()&#123;if(arguments.length&gt;0&amp;&amp;\"return this\"===arguments[arguments.length-1])return function()&#123;return e&#125;&#125;\" 优化方案在小程序环境中是不能偷懒了，需要把之前的代码改写一下。要把 Page 对象也传给调度中心保存起来，作为回调函数调用时的上下文对象。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//event.jsclass Event &#123; on (event, fn, ctx) &#123; if (typeof fn != \"function\") &#123; console.error('fn must be a function') return &#125; this._stores = this._stores || &#123;&#125; ;(this._stores[event] = this._stores[event] || []).push(&#123;cb: fn, ctx: ctx&#125;) &#125; emit (event) &#123; this._stores = this._stores || &#123;&#125; var store = this._stores[event], args if (store) &#123; store = store.slice(0) args = [].slice.call(arguments, 1) for (var i = 0, len = store.length; i &lt; len; i++) &#123; store[i].cb.apply(store[i].ctx, args) &#125; &#125; &#125; off (event, fn) &#123; this._stores = this._stores || &#123;&#125; // all if (!arguments.length) &#123; this._stores = &#123;&#125; return &#125; // specific event var store = this._stores[event] if (!store) return // remove all handlers if (arguments.length === 1) &#123; delete this._stores[event] return &#125; // remove specific handler var cb for (var i = 0, len = store.length; i &lt; len; i++) &#123; cb = store[i].cb if (cb === fn) &#123; store.splice(i, 1) break &#125; &#125; return &#125; &#125; 调用方法也需要改一下，不需要使用 bind 方法了，只需传入 Page 对象： 1app.event.on('afterPaySuccess', this.afterPaySuccess, this) 写在最后一个简单的事件类几十行代码就能写完了，但作为一个基础模块还是有很多可以优化和拓展的地方。有兴趣的同学可以研读一下 nodejs 的 event 模块:https://github.com/nodejs/node/blob/master/lib/events.js，里面对事件类做了很多优化和功能拓展。 另外，小程序的开发过程中相信大家都遇到了不少的坑和发现了一些可以优化的点。为了收集这些开发中的痛点，我们开了一个 issue-list：https://github.com/o2team/wxapp-issue-list/blob/master/issue-list.md，欢迎大家前来提 issue~ 参考 https://github.com/dannnney/weapp-event","pubDate":"Thu, 19 Jan 2017 12:27:00 GMT","guid":"https://aotu.io/notes/2017/01/19/wxapp-event/","category":"Web开发"},{"title":"ELF - 灵活可扩展的 HTML5 构建工具","link":"https://aotu.io/notes/2017/01/17/elf/","description":"ELF，意为小精灵，来自 War3 中暗夜精灵族的农民。 通常当我们开始一个新的 HTML5 场景营销活动项目时，需要创建项目目录，初始化基本的项目文件，然后再添加构建（grunt/gulp/webpack）相关的文件（一次两次三次…，像小精灵采木一样~)，目前有不少工具可以帮我们解决一部分这种重复性的工作，但不能完全的解决，于是，就有了小精灵 - ELF，官网：elf.aotu.io。 快速上手 安装 ELF 支持 Node &gt;= 4，通过 npm 全局安装 1npm install -g elf-cli 但是，由于网络的原因，直接安装估计多半都会在安装 node-sass 和 phantomjs 这两个包时失败，所以，强烈推荐使用下面的命令安装 1234# mac/linux$ SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ PHANTOMJS_CDNURL=https://npm.taobao.org/mirrors/phantomjs/ npm install -g elf-cli --registry=https://registry.npm.taobao.org# windows$ npm install -g elf-cli --registry=https://registry.npm.taobao.org --SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ --PHANTOMJS_CDNURL=https://npm.taobao.org/mirrors/phantomjs/ 安装好后，可以运行 elf --help 查看支持的命令和帮助说明。 初始化项目 假如我们现在要做一个向下整页滑屏的 HTML5 项目 12345678# 运行初始化命令，基于 swiper template 初始化项目$ elf init -t swiper demo-swiper# 进入项目目录，安装依赖$ cd demo-swiper &amp;&amp; npm install# 运行（开发模式）$ elf start 这样一个向下整页滑屏的 HTML5 项目就已运行在开发模式上，样式预处理自动编译、样式热加载等功能早已具备， 在此基础上，你就可以开始按照你的需求愉快的开发了。 部署 当项目开发完成之后，需要将代码合并压缩用于部署，运行 1elf build 会生成一个 dist 文件夹用于部署。 整个流程下来，基本解决了 HTML5 项目开发过程中项目初始化和构建部分的重复工作，已在团队内广泛使用，包括 Q4 京东品牌运营的10多个 H5 项目，如 皇家视频 京东精选 功能介绍ELF 主要包括三部分功能：项目构建、示例模板和通用组件。 项目构建现在在做 web 开发时，基本都会引入构建工具，常用的有 grunt、gulp 以及目前最流行的 webpack，再配合各种插件，好处就不多说了，相信每个使用者都有自己的体会和心得。 ELF 基于 webpack 同时整合了 webpack-dev-server sass-loader、less-loader、style-loader html-webpack-plugin postcss-loader、autoprefixer、postcss-plugin-px2rem、postcss-sprites、postcss-assets image-webpack-loader *-loader … 提供了 开发时样式热加载 支持 Sass、Less 和 Stylus 样式预处理自动编译 Autoprefixer 前缀补全 px -&gt; rem 自动转换 雪碧图合成 自动获取图片 width 和 height 部署构建时图片压缩 部署构建时代码合并压缩 有了这些功能，可以让我们在开发时更多的专注于需求实现上。 示例模板目前提供的 5 个模板项目 基础模板（base） 该示例展示了最基本的项目结构，没有提供额外的功能，可以通过该示例了解整个项目的构建 划屏模板（swiper） 滑屏示例，基于 swiper， 可基于该项目初始化实现滑动翻屏的项目。 场景切换模板（switcher） 场景切换示例，基于 swiper 和 anime.js，可基于该项目初始化实现滑动场景切换的项目。 3D全景模板（panorama） 全景示例，基于 three.js 和 orientation.js，可基于该项目初始化实现重力感应配合全景的项目。 视频播放模板（video） 在手机上使用 video 标签播放视频的基础示例。 通过这些示例，可以快速初始化项目，你也可以根据自己的需求，定制自己的初始项目。 通用组件在项目开发中，有些常用功能已被封装成通用组件，例如：swiper。Github 上有大量优秀的开源组件，基本上能满足你所有需求，本着轮子不嫌多的\u0001精神，也造了两个 elf-preloader.js 预加载图片和音频 elf-orientation.js 处理重力感应 欢迎试用并提供问题或优化反馈~~ 写在最后项目最初的形态是由几个整理的典型示例组成，经过两次迭代重构后变成了现在的样子，在开发过程中的灵感主要来自 create-react-app，并借鉴了其 webpack 配置项。后续计划把 示例模板 那块拆分出来（类似 vue-cli 那样以及基于 Electron 提供 GUI。 欢迎各位同学试用，特别是做 HTML5 场景营销活动的同学，如果在使用过程中遇到什么问题，欢迎提交 issues 和 PR,或者 FORK 构建自己的版本。 Github 地址","pubDate":"Tue, 17 Jan 2017 07:26:37 GMT","guid":"https://aotu.io/notes/2017/01/17/elf/","category":"NodeJS"},{"title":"聊聊 SVG 基本形状转换那些事","link":"https://aotu.io/notes/2017/01/16/base-shapes-to-path/","description":"一、前言前段时间研究 SVG 压缩优化，发现SVG预定义的 rect、circle、ellipse、line、polyline、polygon 六种基本形状可通过path路径转换实现，这样可以在一定程度上减少代码量。不仅如此，我们常用的 SVG Path 动画(路径动画)，是以操作path中两个属性值stroke-dasharray和stroke-dashoffset来实现，基本形状转换为path路径，有利于实现路径动画。 二、SVG基本形状SVG 提供了rect、circle、ellipse、line、polyline、polygon六种基本形状用于图形绘制，这些形状可以直接用来绘制一些基本的形状，如矩形、椭圆等，而复杂图形的绘制则需要使用 path 路径来实现。 1.rect 矩形12&lt;rect x=\"10\" y=\"10\" width=\"30\" height=\"30\"/&gt;&lt;rect x=\"60\" y=\"10\" rx=\"10\" ry=\"10\" width=\"30\" height=\"30\"/&gt; SVG中rect元素用于绘制矩形、圆角矩形，含有6个基本属性用于控制矩形的形状以及坐标，具体如下： 123456x 矩形左上角x位置, 默认值为 0 y 矩形左上角y位置, 默认值为 0width 矩形的宽度, 不能为负值否则报错, 0 值不绘制height 矩形的高度, 不能为负值否则报错, 0 值不绘制rx 圆角x方向半径, 不能为负值否则报错ry 圆角y方向半径, 不能为负值否则报错 这里需要注意，rx 和 ry 的还有如下规则： rx 和 ry 都没有设置, 则 rx = 0 ry = 0 rx 和 ry 有一个值为0, 则相当于 rx = 0 ry = 0，圆角无效 rx 和 ry 有一个被设置, 则全部取这个被设置的值 rx 的最大值为 width 的一半, ry 的最大值为 height 的一半 12345678910rx = rx || ry || 0;ry = ry || rx || 0;rx = rx &gt; width / 2 ? width / 2 : rx;ry = ry &gt; height / 2 ? height / 2 : ry;if(0 === rx || 0 === ry)&#123; rx = 0, ry = 0; //圆角不生效，等同于，rx，ry都为0&#125; 2.circle 圆形1&lt;circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"#fff\"&gt;&lt;/circle&gt; SVG中circle元素用于绘制圆形，含有3个基本属性用于控制圆形的坐标以及半径，具体如下： 123r 半径cx 圆心x位置, 默认为 0cy 圆心y位置, 默认为 0 3.ellipse 椭圆1&lt;ellipse cx=\"75\" cy=\"75\" rx=\"20\" ry=\"5\"/&gt; SVG中ellipse元素用于绘制椭圆，是circle元素更通用的形式，含有4个基本属性用于控制椭圆的形状以及坐标，具体如下： 1234rx 椭圆x半径ry 椭圆y半径cx 圆心x位置, 默认为 0cy 圆心y位置, 默认为 0 4.line 直线1&lt;line x1=\"10\" x2=\"50\" y1=\"110\" y2=\"150\"/&gt; Line绘制直线。它取两个点的位置作为属性，指定这条线的起点和终点位置。 1234x1 起点的x位置y1 起点的y位置x2 终点的x位置y2 终点的y位置 5.polyline 折线1&lt;polyline points=\"60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145\"/&gt; polyline是一组连接在一起的直线。因为它可以有很多的点，折线的的所有点位置都放在一个points属性中： 1points 点集数列，每个数字用空白、逗号、终止命令符或者换行符分隔开，每个点必须包含2个数字，一个是x坐标，一个是y坐标 如0 0, 1 1, 2 2” 6.polygon 多边形1&lt;polygon points=\"50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180\"/&gt; polygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形。 1points 点集数列，每个数字用空白、逗号、终止命令符或者换行符分隔开，每个点必须包含2个数字，一个是x坐标，一个是y坐标 如0 0, 1 1, 2 2， 路径绘制完闭合图形” 三、SVG path 路径SVG 的路径&lt;path&gt;功能非常强大，它不仅能创建基本形状，还能创建更多复杂的形状。&lt;path&gt;路径是由一些命令来控制的，每一个命令对应一个字母，并且区分大小写，大写主要表示绝对定位，小写表示相对定位。&lt;path&gt; 通过属性 d 来定义路径， d 是一系列命令的集合，主要有以下几个命令： 通常大部分形状，都可以通过指令M(m)、L(l)、H(h)、V(v)、A(a)来实现，注意特别要区分大小写，相对与绝对坐标情况，转换时推荐使用相对路径可减少代码量，例如： 1234567// 以下两个等价d='M 10 10 20 20' // (10, 10) (20 20) 都是绝对坐标d='M 10 10 L 20 20'// 以下两个等价d='m 10 10 20 20' // (10, 10) 绝对坐标, (20 20) 相对坐标d='M 10 10 l 20 20' 四、SVG 基本形状路径转换原理1.rect to path如下图所示，一个 rect 是由 4 个弧和 4 个线段构成；如果 rect 没有设置 rx 和 ry 则 rect 只是由 4 个线段构成。rect 转换为 path 只需要将 A ~ H 之间的弧和线段依次实现即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344function rect2path(x, y, width, height, rx, ry) &#123; /* * rx 和 ry 的规则是： * 1. 如果其中一个设置为 0 则圆角不生效 * 2. 如果有一个没有设置则取值为另一个 */ rx = rx || ry || 0; ry = ry || rx || 0; //非数值单位计算，如当宽度像100%则移除 if (isNaN(x - y + width - height + rx - ry)) return; rx = rx &gt; width / 2 ? width / 2 : rx; ry = ry &gt; height / 2 ? height / 2 : ry; //如果其中一个设置为 0 则圆角不生效 if(0 == rx || 0 == ry)&#123; // var path = // 'M' + x + ' ' + y + // 'H' + (x + width) + 不推荐用绝对路径，相对路径节省代码量 // 'V' + (y + height) + // 'H' + x + // 'z'; var path = 'M' + x + ' ' + y + 'h' + width + 'v' + height + 'h' + -width + 'z'; &#125;else&#123; var path = 'M' + x + ' ' + (y+ry) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + rx + ' ' + (-ry) + 'h' + (width - rx - rx) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + rx + ' ' + ry + 'v' + (height - ry -ry) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + (-rx) + ' ' + ry + 'h' + (rx + rx -width) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + (-rx) + ' ' + (-ry) + 'z'; &#125; return path;&#125; 2.circle/ellipse to path圆可视为是一种特殊的椭圆，即 rx 与 ry 相等的椭圆，所以可以放在一起讨论。 椭圆可以看成A点到C做180度顺时针画弧、C点到A做180度顺时针画弧即可。 123456789101112function ellipse2path(cx, cy, rx, ry) &#123; //非数值单位计算，如当宽度像100%则移除 if (isNaN(cx - cy + rx - ry)) return; var path = 'M' + (cx-rx) + ' ' + cy + 'a' + rx + ' ' + ry + ' 0 1 0 ' + 2*rx + ' 0' + 'a' + rx + ' ' + ry + ' 0 1 0 ' + (-2*rx) + ' 0' + 'z'; return path;&#125; 3.line to path相对来说比较简单，如下： 123456789101112function line2path(x1, y1, x2, y2) &#123; //非数值单位计算，如当宽度像100%则移除 if (isNaN(x1 - y1 + x2 - y2)) return; x1 = x1 || 0; y1 = y1 || 0; x2 = x2 || 0; y2 = y2 || 0; var path = 'M' + x1 + ' '+ y1 + 'L' + x2 + ' ' + y2; return path;&#125; 4.polyline/polygon to pathpolyline折线、polygon多边形的转换为path比较类似，差别就是polygon多边形会闭合。 123456789101112131415// polygon折线转换points = [x1, y1, x2, y2, x3, y3 ...];function polyline2path (points) &#123; var path = 'M' + points.slice(0,2).join(' ') + 'L' + points.slice(2).join(' '); return path;&#125;// polygon多边形转换points = [x1, y1, x2, y2, x3, y3 ...];function polygon2path (points) &#123; var path = 'M' + points.slice(0,2).join(' ') + 'L' + points.slice(2).join(' ') + 'z'; return path;&#125; 五、convertpath 转换工具为了方便处理SVG基本元素路径转换，本人抽空写了convertpath工具，具体如下： 安装：1npm i convertpath 使用： 12345678910const parse = require('convertpath');parse.parse(\"./test/test.svg\")/** * &lt;circle cx=\"500\" cy=\"500\" r=\"20\" fill=\"red\"/&gt; */console.log(parse.toSimpleSvg())/** * &lt;path d=\"M500,500,m-20,0,a20,20,0,1,0,40,0,a20,20,0,1,0,-40,0,Z\" fill=\"red\"/&gt; */ 参考资料： Basic Shapes – SVG 1.1 (Second Edition)基本形状 - SVG | MDNSVG (一) 图形, 路径, 变换总结; 以及椭圆弧线, 贝塞尔曲线的详细解释路径 - SVG | MDNXMLDOM","pubDate":"Mon, 16 Jan 2017 04:36:37 GMT","guid":"https://aotu.io/notes/2017/01/16/base-shapes-to-path/","category":"web开发"},{"title":"视频H5のVideo标签在微信里的坑和技巧","link":"https://aotu.io/notes/2017/01/11/mobile-video/","description":"随着 4G 的普遍以及 WiFi 的广泛使用，手机上的网速已经足够稳定和高速，以视频为主的 HTML5 也越来越普遍了，相比帧动画，视频的表现更加丰富，前段时间开发了一个以视频为主的移动端 HTML5，在这里介绍一些实践经验。 统一播放效果我们希望视频播放时可以全屏播放，没有进度条、播放按钮等与系统相关的元素，可以在视频上方增加自定义的元素（比如一个跳过按钮），类型下面的效果： 在不同的操作系统（主要就是 iOS 和 Android），为了达到比较统一的播放效果，分别对其进行兼容。 iOS 在 iOS 上，APP 都是使用的系统自带的浏览器进行页面渲染，video 播放视频的效果是统一的，只需要考虑不同的 iOS 版本是否有不一致的地方。在 iOS 上，播放视频默认会弹出一个播放器全屏播放视频，如下效果 播放器上下有的系统默认的控制栏，可以控制视频的播放进度、音量以及暂停或继续播放，播放视频时，视频会 “浮” 在页面上，页面上的所有元素都只能是在视频下面，这种效果显然不是我们想要的。但好在 iOS 10 Safari 中，video 新增了 playsinline 属性，可以使视频内联播放。 在 webkit 的 blog 上提到 A note about the playsinline attribute: this attribute has recently been added to the HTML specification, and WebKit has adopted this new attribute by unprefixing its legacy webkit-playsinline attribute. This legacy attribute has been supported since iPhoneOS 4.0, and accordance with our updated unprefixing policy, we’re pleased to have been able to unprefix webkit-playsinline. iOS 10 之前的版本支持 webkit-playsinline，但是加了这个属性后，在 iOS 9 的上出现只能听到声音不能看到画面的问题，最后使用的标签代码 1&lt;video id=&quot;video&quot; class=&quot;video&quot; preload=&quot;auto&quot; playsinline src=&quot;http://wqs.jd.com/promote/superfestival/superfestival.mp4&quot; width=&quot;1&quot; height=&quot;1&quot; type=&quot;video/mp4&quot;&gt;&lt;/video&gt; 然后再加上这个库 iphone-inline-video一起使用。 Android 在 Android 上，因为各个软件使用的浏览器渲染引擎不一样，所以视频播放的效果差异也很大，这里主要以微信为主。微信使用的是自带的渲染引擎 TBS，默认的播放效果 在播放器的下方也是会有控制栏，视频也会 “浮” 在页面上。而 Android 是不支持 playsinline 属性使视频内联播放的。但是，如果你看过一些腾讯的视频类 HTML5，会发现它们在微信里是可以内联播放的，而这个功能是需要申请加入白名单的。 不过新版的 \u0002TBS 内核（&gt;=036849）支持一个叫 同层播放器 的视频播放器，这个不需要申请白名单，只需给 video 设置两个属性 x5-video-player-type=&quot;h5&quot; 和 x5-video-player-fullscreen=&quot;true&quot;，播放效果 当点击左上角的箭头的时，会退出播放 退出播放时，我们需要做相应的处理。TBS 有提供相应的事件，不过不同的版本有一点差异 TBS &lt; 036849 036849 &lt;= TBS &lt; 036900 036900 &lt;= TBS 是否支持同层播放器 否 是 是 退出全屏播放时触发 x5videoenterfullscreen x5videoexitfullscreen 进入全屏播放时触发 x5videoexitfullscreen x5videoenterfullscreen 通过监听这两个事件就可以知道当前的播放状态 1234567document.getElementById('video').addEventListener(\"x5videoexitfullscreen\", function()&#123; alert(\"exit fullscreen\")&#125;)document.getElementById('video').addEventListener(\"x5videoenterfullscreen\", function()&#123; alert(\"enter fullscreen\")&#125;) 在对话框中发送 //gettbs 可以查看相关信息，tbsCoreVersion 就是当前安装的 TBS 内核版本。 video 的事件video 支持的事件很多，但在有些事件在不同的系统上跟预想的表现不一致，在尝试比较之后，使用 timeupdate 和 ended 这两个事件基本可以满足需求 1234567video.addEventListener('timeupdate', function (e) &#123; console.log(video.currentTime) // 当前播放的进度&#125;)video.addEventListener('ended', function (e) &#123; // 播放结束时触发&#125;) 视频居中视频的宽高比是固定的，而手机的屏幕宽高比则不是，所以，为了让观看到的视频的体验尽可能一致，以宽度为先，进行适配 1234567891011121314function handleResize() &#123; var sWidth = 9 var sHeight = 16 var width = window.innerWidth var height = window.innerHeight var marginTop = height - (width * sHeight) / sWidth marginTop = Math.round(marginTop) if (marginTop &lt; -2) &#123; video.$wrapper.css('marginTop', marginTop / 2 + 'px') &#125; else &#123; video.$wrapper.css('marginTop', '0') &#125;&#125; 示例在线示例代码仓库 代码基于 ELF 构建，运行示例需要 安装 ELF，欢迎试用反馈。 参考 https://www.w3.org/wiki/HTML/Elements/video http://caniuse.com/#search=video https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Media_events http://zhaoda.net/2014/10/30/html5-video-optimization https://webkit.org/blog/6784/new-video-policies-for-ios/ https://github.com/bfred-it/iphone-inline-video","pubDate":"Wed, 11 Jan 2017 09:36:37 GMT","guid":"https://aotu.io/notes/2017/01/11/mobile-video/","category":"Web开发"},{"title":"在微信小程序里实现图片预加载组件","link":"https://aotu.io/notes/2017/01/06/wxapp-img-loader/","description":"网页中的图片预加载我们知道在 Web 页面中实现图片的预加载其实很简单，通常的做法是在 JS 中使用 Image 对象即可，代码大致如下 12345var image = new Image()image.onload = function() &#123; console.log('图片加载完成')&#125;image.src = 'http://misc.360buyimg.com/lib/img/e/logo-201305.png' 然而在微信小程序（以下简称小程序）里要实现图片的预加载要更麻烦一些，因为小程序里并没有提供类似 Image 这样的 JS 对象。。 小程序必知必会在进入正题前，需要了解以下小程序相关的知识（当然最好还是完整的学习一下官方文档）： 小程序框架的核心是一个响应的数据绑定系统，整个系统分为视图层和逻辑层两块，视图层即页面模板（后缀为 .wxml 的文件），逻辑层即页面 JS 文件 小程序的页面模板由一系列的基础组件组合而成，如 view、text、button 等 页面内容的更新基于数据的单向绑定来进行，通过 JS 调用 Page 对象的 setData 方法来更新模板中绑定的数据 视图层到逻辑层的通信是通过事件完成的，在组件中声明事件的回调，JS 端可监听到界面交互的发生、组件状态的变化等 在 WXML 文件中，可通过 template 进行模板的复用，若 template 是在不同文件里定义的，需要先通过 import 语句进行引入 这里有个官方的简单例子可以用来帮助理解 123&lt;!-- 模板文件 foo.wxml --&gt;&lt;view&gt; Hello &#123;&#123;name&#125;&#125;! &lt;/view&gt;&lt;button bindtap=\"changeName\"&gt; Click me! &lt;/button&gt; 1234567891011//脚本文件 foo.jsPage(&#123; data: &#123; name: 'WeChat' &#125;, changeName: function(e) &#123; this.setData(&#123; name: 'MINA' &#125;) &#125;&#125;) 运行这个页面会看到一行 Hello WeChat! 的文字及一个按钮，点击按钮后文字会变成 Hello MINA! 在小程序中加载图片小程序提供一个 image 组件（类似于 HTML 中的 img 标签），可以设置 src 及加载成功或失败的回调，使用起来很简单 12&lt;!-- 模板文件 bar.wxml --&gt;&lt;image src=\"http://misc.360buyimg.com/lib/img/e/logo-201305.png\" bindload=\"imageOnLoad\" binderror=\"imageOnLoadError\" /&gt; 123456789//脚本文件 bar.jsPage(&#123; imageOnLoad(ev) &#123; console.log(`图片加载成功，width: $&#123;ev.detail.width&#125;; height: $&#123;ev.detail.height&#125;`) &#125;, imageOnLoadError() &#123; console.log('图片加载失败') &#125;&#125;) 运行以上代码，顺利的话页面上会显示出一张图片，同时控制台会打印出带图片宽高的日志信息 将功能抽离成公用组件接下来我们考虑实现这么一个功能，在页面上载入一张尺寸和 K 数都很大的图片，由于图片很大，下载需要一定的时间，而在这段时间内，用户看到的是空白或是不完整的图片，体验显然不好。 一种常用的优化手段是先加载一张缩略图，该缩略图通过样式设置为和原图一样的宽高，这样用户首先能很快速地看到一张模糊的图片，此时再去对原图做预加载，加载完成之后对缩略图进行替换，因为此时图片已经下载过了，所以界面上能无缝地切换为原图显示，效果如下： 完成这个优化操作的关键就在于需要一个公共的图片预加载组件的支持，接下来我们分步骤来看看如何实现 新建 demo 页面及组件相关的文件 img-loader.js 和 img-loader.wxml，组件需要和页面一样有个模板文件，是因为小程序里无法动态地插入模板结构。然后在 demo.wxml 里通过 import 语句引用组件模板，在 demo.js 里通过 require 语句将组件脚本进行引入 在页面中通过 template 调用组件模板并传入数据，这里我们传递一个名为 imgLoadList 的图片数组过去 在页面脚本中的 onLoad 方法中对组件进行初始化，并将 this 对象传入，因为组件内必须通过 Page 对象的 setData 来更新模板里的内容 在组件的 img-loader.js 中定义一个 load 方法用来创建一个图片的加载，将传入的 src 添加到加载队列中，并使用 setData 方法更新队列数据 接下来在组件 img-loader.wxml 中通过接收到的图片队列数据，用 wx:for 指令去生成 image 组件来对图片进行加载，同时将成功及失败的回调绑定到 img-loader.js 中的方法中，最终再回调回 Page 对象中 可以看出，由于小程序里无法动态地插入模板结构，所以相对于普通网页端的组件调用，这里多出了在 WXML 文件中引入及使用模板这个步骤，而其他部分对于调用方（即Demo 页面）来说则是相似的，下面是完整的 Demo 页面的代码 12345678910111213&lt;!-- demo.wxml --&gt;&lt;view class=\"img_wrap\"&gt; &lt;image wx:if=\"&#123;&#123; imgUrl &#125;&#125;\" src=\"&#123;&#123; imgUrl &#125;&#125;\" /&gt;&lt;/view&gt;&lt;button bindtap=\"loadImage\"&gt;Click To Load Image&lt;/button&gt;&lt;view class=\"msg\"&gt;&#123;&#123; msg &#125;&#125;&lt;/view&gt;&lt;!-- 引入图片预加载组件 --&gt;&lt;import src=\"../../img-loader/img-loader.wxml\"/&gt;&lt;template is=\"img-loader\" data=\"&#123;&#123; imgLoadList &#125;&#125;\"&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536// ------ demo.js ------//引入图片预加载组件const ImgLoader = require('../../img-loader/img-loader.js')//缩略图 80x50 3KBconst imgUrlThumbnail = 'http://storage.360buyimg.com/mtd/home/lion1483683731203.jpg'//原图 3200x2000 1.6MBconst imgUrlOriginal = 'http://storage.360buyimg.com/mtd/home/lion1483624894660.jpg'Page(&#123; data: &#123; msg: '', imgUrl: '' &#125;, onLoad() &#123; //初始化图片预加载组件 this.imgLoader = new ImgLoader(this) &#125;, loadImage() &#123; //加载缩略图 this.setData(&#123; msg: '大图正拼命加载..', imgUrl: imgUrlThumbnail &#125;) //同时对原图进行预加载，加载成功后再替换 this.imgLoader.load(imgUrlOriginal, (err, data) =&gt; &#123; console.log('图片加载完成', err, data.src) this.setData(&#123; msg: '大图加载完成~' &#125;) if (!err) this.setData(&#123; imgUrl: data.src &#125;) &#125;) &#125;&#125;) 如果把图片加载完成的回调统一指定成 Page 对象中的方法，则可以很方便地处理多张图片的加载，这里也写了个例子，效果如下： 总的来说调用起来还算方便吧，img-loader 的组件代码略多这里就不贴出来啦，有兴趣的同学可以前往 Github 项目页面 查看，目前此组件已应用在京东购物小程序版中。Have Fun~","pubDate":"Fri, 06 Jan 2017 10:00:00 GMT","guid":"https://aotu.io/notes/2017/01/06/wxapp-img-loader/","category":"Web开发"},{"title":"第2季极客沙龙资料分享 - 知行·前端体验主题交流会","link":"https://aotu.io/notes/2017/01/04/geek-talks-s2/","description":"极客沙龙(Geek Talks)，没有固定的主办方，每Q一次，由凹凸实验室联合别的公司、团队一起举办的开放技术分享品牌，面向全栈，核心关注的是移动互联网的技术领域。 本季极客沙龙(Geek Talks) 为鹅厂Fit主办，凹凸实验室、QQ浏览器团队、腾讯TGideas团队联合协办，其主题为「知·行」。 事实上距分享会已过了整整7天，因为我最近拖沓的症状，今天才补上分享会的课件分享。而巧的是，关于治疗拖沓症的具体办法，恰巧可以参考本次分享会来自TGIdeas黄文杰同学分享的「前端开发的自我修养」。 小花絮抽奖签到券用sketch设计的简单抽奖签到券，虽然不是专业设计师，但是还能看吧。 给签到券印上编号心灵手巧的硬妹子EC，凹凸实验室的动效一姐，目前单身！ 茶歇听听分享，吃吃东西。 分享嘉宾合照前段时间「张小龙今天的一张照片，暴露了程序员的审美」刷屏了， 我们的嘉宾显然朝气蓬勃许多吧，左二、三，90后，上个月撸完京东首页改版，右一潮男，右三是会弹吉他的奶爸。 对于审美的话题，引用网友的一句评论：审美在能改变世界的人和金钱面前算个逑。 主题简评及课件下载重构眼中的微信小程序这个分享主要抛出了一种「以现有Web开发构建手段去开发微信小程序」的思路，有点类似「用Reactjs去开发原生APP」的感觉。微信小程序如果真能火起来，将来势必会有很多的开发小程序的工具、系统或框架。 课件下载：重构眼中的微信小程序 京东购物之微信小程序诞生记如果说前面的主题是对小程序的探索和构想，那末这个分享则是实际项目的总结分享。整个讲义非常详细地介绍了「京东购物小程序」的项目背景，分享了开发过程中的坑和技巧。 课件下载：京东购物之微信小程序诞生记 京东首页前端优化之路尽管是后PC时代，但是前端工程化构建以及极致优化的思想一直是热门且通用的课题。 这个分享主要介绍京东首页的整体技术架构和团队开发模式，以及在此次优化过程中所面临的性能、体验、页面可用性等方面的挑战和解决之道。 课件下载：京东首页前端优化之路 前端开发的自我修养 工作中没有脱离项目执行和管理的技术 本次极客沙龙唯一一个非技术性的分享，中间提及的工作思路和感悟可以受用在日常的技术实践过程中。 现在觉得无聊的童鞋可以过两年再回来看看，技术会更新迭代，而修养的话题却是持久不变。 课件下载：前端开发的自我修养 地铁线路图选站实践分享这位同学的SVG玩的很6. SVG在地铁线路图选站项目中的开发实践。技术实现之余，将一起思考探讨在大前端浪潮中，如何选择重构的工作范围，做与不做，一念之间，干系万千。 课件下载：地铁线路图选站实践分享 ServiceWorker介绍了传统WEB开发的痛点，并以DEMO的形式展示了 ServiceWorkers相关技术实践，以及相关进阶扩展和工具配置。 如果没记错，vue2.0的一个有名的开源案例vue-hackernews-2.0 也有SW的实际应用。 课件下载：ServiceWorker 下一季极客沙龙预告第3季将会是「微信小程序专场分享」，今年3月份举办，有兴趣的同学可以关注下。","pubDate":"Wed, 04 Jan 2017 03:35:12 GMT","guid":"https://aotu.io/notes/2017/01/04/geek-talks-s2/","category":"资源合集"},{"title":"一个栗子实践vue2.0与1.0的区别","link":"https://aotu.io/notes/2016/12/28/vue-clock/","description":"序言本文通过一个初熟的小栗子来实践2.0与1.0的不同之处，最终的效果如下图所示： 提示 可作为vue2.0+vuex入门参考 只粘贴核心代码，看源码建议直接下载demo 其实只有sass没有贴上啦 demo在移动端亲测可用 搭建项目知识点这个栗子将涉及以下知识点： vue2.0 vue-cli脚手架 vuex状态管理库 webpack 版本声明本篇文章的版本： node: v6.2.0 vue: v2.1.0 vuex: v2.0.0 vue-router: v2.1.1 webpack: v1.13.2 文件目录 安装首先请确保已安装了node、npm、webpack。 安装vue脚手架。 1npm install vue-cli -g 选择一个目录并执行。 1vue init webpack 项目名字 或者vue init webpack-simple 项目名字 &lt;注意不能用中文&gt; 然后根据命令行的相关提示输入信息； webpack与webpack-simple两者的区别在于webpack-simple没有包括eslint等功能，普通的项目用simple就好了； 我使用的是前者。 进入项目目录下载相关依赖。 12cd 项目目录npm install 启动。 1npm run dev 这一行命令会自动启动浏览器并运行项目(如果你不想占用8080端口，可通过 项目 /config/index.js 中的port修改)。 初始化初始化入口js文件 main.jsmain.js是应用入口文件，可以在这里 配置路由vue-router 引入路由子组件 引入状态管理store(注入所有子组件) 实例化Vue 引入公共样式等 已完成的main.js如下： 懒癌患者可直接拷贝 123456789101112131415161718192021222324252627282930313233343536373839import Vue from 'vue'import store from './store'//引入路由及组件import VueRouter from 'vue-router'import App from './App'import Home from './components/Home'import Clocklist from './components/Clocklist'//引入公共cssimport './static/css/reset.css'Vue.use(VueRouter)//定义路由const routes = [ &#123; path : '/', component : Home &#125;, &#123; path : '/home', component : Home &#125;, &#123; path : '/clocklist', component : Clocklist &#125;,]//创建实例const router = new VueRouter(&#123; routes&#125;)//实例化，并将store、router挂载到根实例，从而应用到整个项目new Vue(&#123; store, router, ...App&#125;).$mount('#app')//或者直接在options里声明挂载的el 与1.0的不同 映射路由：1.0是通过router的map方法映射路由，并且map接收的是一个对象，2.0中map()被替换了，通过实例化VueRouter并定义一个数组来映射路由； 初始化路由：1.0通过router.start()来初始化路由，2.0中router.start()被替换了，直接通过挂载到vue根实例进行初始化 初始化根组件App.vue在App.vue中添加路由，并引入Sidebar.vue组件，对应的样式直接写在每个独立的组件下，注意这里使用了sass语法，需在 ./build/webpack.base.conf.js 中配置，如下所示： 123456789101112vue: &#123; loaders: utils.cssLoaders(&#123; sourceMap: useCssSourceMap &#125;), postcss: [ require('autoprefixer')(&#123; browsers: ['last 2 versions'] &#125;), require('postcss-import'), require('postcss-sass-extend'), require('postcss-simple-vars'), require('postcss-nested')//sass嵌套语法，其他的看最后一个单词就知道是干什么的了 ] &#125; 下面附上整个App.vue的代码，注意看注释掉的部分哦。 从这里开始后面的sass不贴出来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;template&gt; &lt;!-- 不加会报错 --&gt; &lt;div class=\"clock_wrap\"&gt; &lt;!--S 头部 --&gt; &lt;section class=\"clock_header\"&gt; &lt;h1&gt;计时器&lt;/h1&gt; &lt;/section&gt; &lt;!--E 头部 --&gt; &lt;section class=\"clock_container\"&gt; &lt;!--S 导航 --&gt; &lt;nav class=\"clock_nav\"&gt; &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/clocklist\"&gt;计时列表&lt;/router-link&gt; &lt;/nav&gt; &lt;!--E 导航 --&gt; &lt;!--S sidebar --&gt; &lt;div class=\"clock_sidebar\"&gt; &lt;sidebar&gt;&lt;/sidebar&gt; &lt;/div&gt; &lt;!--E sidebar --&gt; &lt;!--S 路由部分 --&gt; &lt;div class=\"clock_router\"&gt; &lt;!-- &lt;transition mode=\"out-in\"&gt; --&gt; &lt;transition :name=\"transitionName\"&gt; &lt;router-view class=\"clock_router_inner\"&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt; &lt;!--E 路由部分 --&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Sidebar from './components/Sidebar.vue'export default &#123; data:function()&#123; return &#123; transitionName: 'slide-left' &#125; &#125;, mounted:function()&#123; if(this.$route.name==undefined)&#123; this.$router.push('home'); &#125; &#125;, /*watch: &#123; '$route' (to, from) &#123; console.log(to.path) &#125; &#125;,*/ components: &#123; Sidebar &#125;&#125;&lt;/script&gt;&lt;style&gt;@import './static/sass/_function.scss';body &#123; overflow: hidden;&#125;.clock_header &#123; height: 42px; line-height: 42px; background: #39383e; h1 &#123; font-size: 18px; color: #fff; text-align: center; &amp;::before &#123; content: ''; width: 18px; height: 18px; display: inline-block; vertical-align: middle; margin: -2px 5px 0 5px; background: url(./static/img/logo.png) no-repeat; background-size: 100% 100%; &#125; &#125;&#125;.clock_nav &#123; height: 36px; line-height: 36px; background: #f0eff5; padding-left: 5px; font-size: 0; a &#123; display: inline-block; padding: 0 10px; position: relative; font-size: 14px; &amp;.router-link-active &#123; color: $color_red; &#125; &amp;:not(:last-child) &#123; &amp;::after &#123; content: ''; width: 1px; background: #e1e0e6; position: absolute; right: 0; top: 12px; bottom: 12px; &#125; &#125; &#125;&#125;.clock_container &#123; @extend %clearfix;&#125;.clock_sidebar &#123; width: 30%; float: left; box-sizing: border-box; border: 1px solid #ddd; margin-top: 10px;&#125;.clock_router &#123; width: 70%; float: left; position: relative; &amp;_inner &#123; position: absolute; left: 0; right: 0; top: 0; transition: all .3s linear; &#125;&#125;.slide-left-enter&#123; opacity: 0; transform: translate3d(60px, 0, 0);&#125;.slide-left-leave-active &#123; opacity: 0; transform: translate3d(-60px, 0);&#125;&lt;/style&gt; 这里我将路由样式设置为相对定位，路由的子组件设置为绝对定位，可以解决切换路由的时候页面抖动问题。 与1.0的不同 根元素：在2.0中template下需要有一个根元素（clock_wrap），否则会报错； 路由导航：在1.0中我们通过v-link来指定导航链接，在2.0中可以直接使用router-link组件来导航，在浏览器中渲染后是一个a标签,并且会自动设置选中的class属性值.router-link-active， 然后通过to 属性指定链接； 过渡：在1.0中通过在目标元素（router-view）使用transition与transition-mode添加过渡，在2.0中，则改成了使用transition标签包裹目标元素，可以自定义name过渡，也可以使用自带的mode添加过渡动效(如mode=”out-in”)，2.0中也支持通过$route设置基于路由的动态过渡； 钩子：在1.0中的ready已经被mounted取代，此外2.0还新增了beforeMount、beforeUpdate、update等，下面是1.0与2.0生命周期示意图 1.0 2.0 创建首页Home.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div class=\"clock_time\"&gt; &lt;!-- &lt;div class=\"clock_time_inner\" v-html = \"time\"&gt; --&gt; &lt;div class=\"clock_time_inner\"&gt; &lt;i&gt;&#123;&#123;hour&#125;&#125;&lt;/i&gt; &lt;span&gt;:&lt;/span&gt; &lt;i&gt;&#123;&#123;minute&#125;&#125;&lt;/i&gt; &lt;span&gt;:&lt;/span&gt; &lt;i&gt;&#123;&#123;second&#125;&#125;&lt;/i&gt; &lt;/div&gt; &lt;div class=\"clock_time_btn\"&gt; &lt;span @click = 'doClock' v-bind:id=\"clockId\"&gt;开始计时&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; //time: '', hour: '', minute: '', second: '', clockId: 'clock_time' &#125; &#125;, mounted () &#123; this.nowTime() &#125;, methods: &#123; nowTime () &#123; const t = new Date(), h = t.getHours(), m = t.getMinutes(), s = t.getSeconds() //this.$data.time = '&lt;i&gt;' + h +'&lt;/i&gt;&lt;span&gt;:&lt;/span&gt;&lt;i&gt;' + m +'&lt;/i&gt;&lt;span&gt;:&lt;/span&gt;&lt;i&gt;' + s + '&lt;/i&gt;' this.$data.hour = h this.$data.minute = m this.$data.second = s setTimeout(() =&gt; &#123; this.nowTime() &#125;, 1000) &#125;, doClock () &#123; const nowTime = new Date() //状态 this.$store.dispatch('changeStatus') //时长 this.$store.dispatch('addDuration') //计时列表 this.$store.dispatch('saveClockList', nowTime) &#125; &#125; &#125;&lt;/script&gt; 通过nowTime ()方法获取当前的时间，doClock ()分别变更状态、时长以及存储计时记录，后面会讲到vuex部分。 与1.0的不同 数据绑定：与1.0一样绑定数据的形式都使用“Mustache” 语法，但2.0不能在html属性中使用了，比如栗子中的绑定id 的方法v-bind:id=”clockId”而不能直接使用{{clockId}}，否则会报错； 真实的html：1.0中输出真实的html是使用三个大括号{{{ }}}，2.0之后需要使用v-html指令，如上面注释掉的部分所示； 创建侧边栏Sidebar.vue12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=\"clock_sidebar_inner\"&gt; &lt;div class=\"clock_sidebar_item\"&gt; &lt;span class=\"clock_sidebar_title\"&gt;状态&lt;/span&gt; &lt;span class=\"clock_sidebar_desc\" :class = \"&#123; 'green': status == '已计时', 'red': status == '已结束' &#125;\"&gt;&#123;&#123; status &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"clock_sidebar_item\"&gt; &lt;span class=\"clock_sidebar_title\"&gt;时长&lt;/span&gt; &lt;span class=\"clock_sidebar_desc\"&gt;&#123;&#123; duration &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; status() &#123; return this.$store.getters.getStatus &#125;, duration() &#123; return this.$store.getters.getDuration &#125; &#125; &#125;&lt;/script&gt; 通过计算属性computed去获取状态与时长。 继续创建打卡列表Clocklist.vue1234567891011121314151617181920&lt;template&gt; &lt;div class=\"clock_record\"&gt; &lt;div class=\"clock_record_nothing\" v-if = \"!list.length\"&gt;没有记录&lt;/div&gt; &lt;div class=\"clock_record_item\" v-else = \"list.length &gt; 0\" v-for = \"(item, index) in list\"&gt; &lt;div class=\"clock_record_name\"&gt;&lt;i&gt;&#123;&#123;index + 1&#125;&#125;&lt;/i&gt;&#123;&#123; item.date &#125;&#125;&lt;/div&gt; &lt;div class=\"clock_record_desc\"&gt;计时开始 &#123;&#123; item.gotowork &#125;&#125;&lt;/div&gt; &lt;div class=\"clock_record_desc\"&gt;计时结束 &#123;&#123; item.gooffwork &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; list () &#123; return this.$store.getters.switchTime &#125; &#125; &#125;&lt;/script&gt; 与1.0的不同 v-else-if：在2.0中新增了v-else-if，类似于js中的else if，不能单独使用，需跟在v-if之后； v-for：在使用v-for遍历对象的时候，当存在index时，1.0的参数顺序是(index, value)，2.0变成了(value, index)； v-for：1.0中，v-for块内有一个隐性的特殊变量$index可以获取当前数组的索引，在2.0中移除了，改为了以上这种显式的定义方式； key：key替代track-by vuex部分vuex是为vue.js设计的一个状态管理模式，主要是用来存储共享状态、实现数据通信，简单理解就是统一管理和维护各个vue组件的状态 ，它可以解决多层嵌套组件的传参、兄弟组件的状态传递等难题， 代码更结构化且容易维护。核心概念包括State、Getters、Mutations、Actions、Modules。 创建index.js在src目录新建store文件夹用来存放共享数据(vuex)，然后新建index.js，用来初始化并导出 store。 store已经在main.js中引入 12345678910111213141516import Vue from 'vue'import Vuex from 'vuex'import state from './state'import getters from './getters'import mutations from './mutations'import actions from './actions'Vue.use(Vuex)export default new Vuex.Store(&#123; state, getters, mutations, actions strict: process.env.NODE_ENV !== 'production', //是否开启严格模式&#125;) strict为是否开启严格模式，在这种模式下任何状态变更不是由Mutation函数触发的都会报错，但是为了避免性能损失，不要在发布环境开启严格模式；在构建大型应用时，store对象会变的非常臃肿，Vuex允许将store分割为模块（module）,每个模块有自己个State、Mutations、Actions、Getters。 12345678910111213141516171819const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;) 创建state.js在store目录下继续创建state.js,代码如下 123456789const state = &#123; status: '已结束', duration: '0', timer: null, len: 0, clockList: []&#125;export default state Vuex使用一个state包含了全部的应用层级状态–也就是一个单一状态树；通常在计算属性(computed)返回(检测到数据发生变动时就会执行对相应数据有引用的函数)，如下：12345computed: &#123; list () &#123; return this.$store.state.status &#125;&#125; 创建mutations.js在store目录下继续创建mutations.js。 12345678910111213141516171819202122232425262728293031import * as types from './mutation-types'export default &#123; [ types.CHANGE_STATUS ] ( state) &#123; if( state.status === '已结束' ) &#123; state.status = '已计时' &#125;else if(state.status === '已计时') &#123; state.status = '已结束' &#125; &#125;, [ types.ADD_DURATION ] ( state, obj ) &#123; if( state.status === '已计时' ) &#123; state.duration = obj.time state.timer = obj.timer &#125;else &#123; clearInterval(obj.timer) &#125; &#125;, [ types.SAVE_CLOCK_LIST] (state, nowTime) &#123; if( state.status === '已计时' ) &#123; console.log(state.clockList.length) state.len = state.clockList.length state.clockList.push(&#123;\"gotowork\": nowTime, 'gooffwork': ''&#125;) &#125; if( state.status === '已结束' ) &#123; state.clockList[state.len].gooffwork = nowTime &#125; &#125; &#125; mutations是注册各种数据变化的方法，它接受state作为第一个参数，需注意以下几点 变更state必须通过mutation提交，这样使得我们可以方便地跟踪每一个状态的变化 mutation 必须是同步函数，异步应在action操作 通常使用常量替代mutation事件类型,在实际操作中通常会建立一个mutation-types.js来存储mutation常量，这样的好处是可以对整个 app 包含的 mutation 一目了然 创建mutation-types.js在store目录下继续创建mutation-types.js，用来存储mutation事件名 123export const CHANGE_STATUS = 'CHANGE_STATUS'export const ADD_DURATION = 'ADD_DURATION'export const SAVE_CLOCK_LIST = 'SAVE_CLOCK_LIST' 创建actions.jsaction类似autation，与之不同的是： action不能直接变更state，而是提交mutation action可包含异步操作，而mutation不能（严格模式下报错） Action基本语法如下： 12345actions: &#123; someMethod (context) &#123; context.commit('someMethod') &#125;&#125; action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。在实践中，通常使用 ES2015 的 参数解构简化代码，如下： 12345actions: &#123; someMethod (&#123; commit &#125;) &#123; commit('someMethod') &#125;&#125; 最后附上actions.js的所有代码 1234567891011121314151617181920212223242526272829303132333435import * as types from './mutation-types'export default &#123; changeStatus(&#123; commit &#125;) &#123; commit(types.CHANGE_STATUS) &#125;, addDuration(context) &#123; let num = 1, obj = &#123;&#125; if(context.state.status === '已计时') &#123; obj.timer = setInterval(() =&gt; &#123; let h = parseInt(num / 3600), m = parseInt(num / 60), s = num if(s &gt;= 60) &#123; s = s % 60 &#125; if(m &gt;= 60) &#123; m = m % 60 &#125; obj.time = h + '时' + m + '分' + s + '秒' context.commit(types.ADD_DURATION, obj) num ++ &#125;, 1000) &#125;else &#123; context.commit(types.ADD_DURATION, obj) &#125; &#125;, saveClockList(&#123; commit &#125;, nowTime) &#123; commit(types.SAVE_CLOCK_LIST, nowTime) &#125;&#125; 创建getters.js12345678910111213141516171819202122232425262728export default &#123; getStatus:state =&gt; state.status, getDuration:state =&gt; state.duration, switchTime:state =&gt; &#123; //转换前 let date = '', toTime = '', offTime = '', list = [] //转换后 let switchDate = '', switchToTime = '', switchOffTime = '' state.clockList.forEach(function (v, i) &#123; switchDate = v.gotowork.getFullYear() + '年' + ( v.gotowork.getMonth() + 1 ) + '月' + v.gotowork.getDate() switchToTime = v.gotowork.getHours() + ':' + v.gotowork.getMinutes() + ':' + v.gotowork.getSeconds() if(v.gooffwork !== '') &#123; switchOffTime = v.gooffwork.getHours() + ':' + v.gooffwork.getMinutes() + ':' + v.gooffwork.getSeconds() &#125;else &#123; switchOffTime = '' &#125; list.push(&#123;'date': switchDate, 'gotowork': switchToTime, 'gooffwork': switchOffTime&#125;) &#125;) return list &#125;&#125; getter接收state作为第一个参数，我们可以通过它 获取state的状态 对需要返回的数据进行处理，如过滤、转换等 关于代码结构只要遵守了vuex的规则，如何组织代码可根据项目的实际情况以及个人、团队的使用习惯，vuex并不会限制你的代码结构。所以，放开手脚一起搞事吧！ 以上就是整篇文章的所有内容，如有错误，恳请指正！ 反正咱也不改 写在最后不得不说前端的技术更新真是快啊，从来没有哪个行业像前端这样繁荣却又令人不安。作为前端人，我们唯有保持对新技术敏锐的嗅觉与热情，才能避免被技术前进的浪潮拍在沙滩上，正所谓路漫漫其修远兮，吾将…好了好了，搬砖去了… 参考资料http://cn.vuejs.org/v2/guide/http://vuex.vuejs.org/zh-cn/getting-started.htmlhttps://gold.xitu.io/post/583d1fe00ce463006baca2fahttps://aotu.io/notes/2016/10/13/vue2/","pubDate":"Wed, 28 Dec 2016 09:35:12 GMT","guid":"https://aotu.io/notes/2016/12/28/vue-clock/","category":"Web开发"},{"title":"京东2016版首页改版前端总结","link":"https://aotu.io/notes/2016/12/26/jd-index-2016-summary/","description":"深圳的天气总是多变，前一段时间还是凉意浓浓，似乎要步入冬天了，最近却又变得炎热起来，气温骤升，让人措手不及。正如我们负责的业务一样，一年下来有诸多变化。今年9月份我们接手了京东2016版首页改版开发，历经1个多月紧张地开发测试，终于在双11前成功全量发布，回想整个开发历程，感觉还是有很多值得思索的地方，例如北京一月，虽然日夜颠倒，加班不止，但整个人居然胖了许多，不禁让人匪夷所思。 整体架构最初听说要做新版京东首页的时候，是怀有一丝惶恐的，毕竟是作为京东的门户，其重要性和受关注程度自然不言而喻，一行代码的失误可能会造成不可挽回的后果，而且过去的首页无论性能，还有体验在业界都已经是做得非常优秀了，要再想有些出彩的地方，也是十分困难，所以综上就是压力山大。当然，花开两朵，咱们单表一枝，本文主要还是相对这次改版工作中提炼的工作方法和优化方式做出一定的总结。 这次改版，在前端架构上大体还是沿用过去的架构，使用 jQuery + Seajs 这种古老的开发方式，因为首页还依赖着许多旧的系统与组件，无法在短时间内对基础架构进行升级，当然并不是说旧的就不好，要去盲目追求一些新的东西，而是这种架构还是有可以提升的地方。 而整个项目的架构是经历之前业务进行总结提炼出来的 Athena前端工程化工具，是我们团队自己探索开发的一套基于NodeJs的命令行式前端工程化工具，解决了自动化编译、代码处理、依赖分析、文件压缩等前端开发中的常规问题，有效地提升了我们的工作效率，解放生产力，目前已经应用于我们团队的多个业务中，首页改版也使用Athena来进行开发； Athena管理平台，是Athena工具配套的管理后台，它会收集本地工具操作中上报的统计数据，包括项目、模块、页面、组件创建的信息，文件、资源依赖关系的信息等，通过这些数据来进行项目和资源的管理，同时提供了项目模板，方便使用本地工具创建项目时选择，具体可以参考之前的博文我们是如何做好前端工程化和静态资源管理； Athena组件平台，是基于Athena总结的一套业务组件的平台，可以很好地管理我们的业务组件，方便组件的复用和传播； Athena基础库及组件库，是业务中总结出的基于jQuery + Seajs的js库，简化业务开发，提供完整的框架； Athena模拟接口，可以自由编辑生成指定接口的假数据，用于开发时真实接口的替代，让开发不再依赖后端接口； Athena兜底接口服务，可以指定接口生成一份兜底数据接口，平台会定时去抓取指定接口数据，然后生成兜底数据到CDN，从而生成对应的兜底接口，这样让正常接口多一份兜底保障； Athena前端监控，通过在页面中进行埋点上报的方式，我们可以在监控系统中，实时地看到性能相关数据。我们进行上报的不止有页面性能、速度相关的数据，同时会上报用户的环境信息，例如操作系统、浏览器、网速等，而且还会对页面中错误信息进行上报，如模块的隐藏等，通过这些数据，对我们的业务进行实时地监控与分析。 在我们的架构中，各种各样的工具与系统相辅相成，覆盖到了开发到上线的各个环节，自成一套体系。这样的架构不止是针对首页这个业务的，而是在基于对之前业务开发总结的基础上进行完善、调整的架构，适用于我们各个业务。而这次首页的改版中，我们对开发模式、性能优化、体验优化都进行了一些新的探索，让我们对于业务开发的整体解决方案又有了新的改进。 开发模式Athena开发效率的提升是我们一直追求的，工欲善其事，必先利其器，我们通过总结以往的开发工作，提出了各种手段来优化我们的开发效率，前端工具Athena就是其中的一个产物，当然它又不仅仅是为了提升开发效率而已，它是我们总结出的一套针对前端开发的完整解决方案，可以让我们的整体开发流程更加简单明了。 Athena提供了统一的项目架构，根据业务功能不同，我们将一个项目(app)拆分成不同的业务模块(module)，而每一个模块都包含自身的页面(page)以及构成页面所需要的组件(widget)。 在本地使用Athena创建完整的项目结构，随后我们就可以只关注代码逻辑的书写，Athena提供了简便的操作命令可以一键式地实时编译预览我们的页面，从而让我们不必去关心文件处理、代码编译等细节，开发完后，可以通过Athena执行完整的编译步骤并同步到我们的服务器上方便进行浏览测试。 使用Athena，新版首页开发模式大致如下： 前后端分离基于Athena工具，我们目前已经可以做到完全地本地开发调试了，但是还并不能做到完全的前后端分离，以过去首页为例，页面被拆分成首屏和楼层，首屏采用直出的方式以提升速度，楼层则使用异步加载的方式，拉取服务器上已经渲染好的HTML字符串，如图 整个页面，包括首屏和楼层，都需要前端写好静态HTML，然后给后端开发同学来套用，转成后端语言对应的模板，这样导致前后端耦合较深，HTML更新极不方便，开发成本较高。 为了解决这样前后端耦合的问题，减少沟通成本，这次首页改版我们使用了新的开发方式，为了保证首屏速度，首屏依然采用直出的方式，但对非首屏的楼层进行改进，使用前端模板 + 数据开发方式，将DOM字符串的渲染放到前端来做，后端只提供数据接口，以此来达到前后端分离的效果，同时在开发中使用假数据平台模拟接口，让前端工作不再依赖后端。 在最开始提出这样前后端分离方案的时候还是受到了不少的质疑，因为使用前端模板 + 数据开发方式，会使得每个楼层都多一个接口，并且需要依靠JS来动态渲染，会影响到楼层加载的性能，但经过我们的测试证明在现代PC浏览器下两种模式前端渲染和后端渲染并不会相差太多，并且在模板、数据双重缓存下，这样的差距更是微乎其微了，更关键的是能让我们的开发效率有所提升。 当然，我们对于性能的追求总是孜孜不倦，为了让楼层的加载速度更快，减少请求，我们在后续将使用在服务端定时获取数据编译前端模板，然后生成静态文件推送到CDN的方式来改进，和之前的由后端开发同学套模板生成静态文件不同的是，我们将自己搭建这样的中间层服务，在服务端编译前端模板，实现前后端同构，而前端可以随时切换渲染方式，改成请求渲染好的 HTML 字符串来进行加载，以此来提升性能。 对性能优化的探索性能永远是前端工程师追求的主题，过去首页在性能优化上已经做得非常极致了，它已经使用了各种手段来优化性能，包括首屏直出、样式直出来提升首屏速度，楼层按需加载，减少不必要的请求等等，所以在做新版首页的时候，我们感觉战战兢兢，因为改版不能让页面受到影响，而且最好还能比原来更快，所以，这次改版中我们主要通过如下手段来进行性能的优化。 首屏直出和精简首屏直出是让首屏速度更快的最佳选择，此次版本依然选择了首屏直出的方式，直出的内容包括首屏HTML，页面楼层骨架，以及样式和一些必须的脚本，看起来和之前的方式如出一辙，但此次改版我们还是做了很大的改进，那就是让首屏更加精简。 过去是将页面引用的所有样式都直出在页面上，没有外链的CSS，各种优化手段都考虑进去了，那么新版首页就只能在精简大小上下功夫了，所以新版首页的首屏只直出了首屏必须的样式，同时只直出一小部分必须的脚本，而非首屏的楼层样式拆分到各自楼层中，和楼层的模板放在一起，按需加载。 通过对Athena工具的改造，我们实现样式、模板的统一抽离这一功能，并且是在项目编译阶段自动实现的，开发者勿需关心。由于Athena统一的项目结构，每一个楼层在我们的项目中对应一个widget的组件，组件包含自己的HTML 、CSS、 JavaScript文件，同时widget的组件是可以继续调用其他widget的组件的，所以在编译时，工具会自动分析所有widget的依赖关系，然后把楼层的模板和所有引用到样式打包到一个文件中。最后在楼层加载的时候去请求这个文件，然后解析加载。这样的抽离工作会在最后的项目编译阶段进行，而进行本地开发预览的时候并不会执行，这样保证了开发的效率。 1234567// https://misc.360buyimg.com/mtd/pc/index/home/rec_tpl.min.jsjsonCallBack_rec_tpl(&#123; dom: '&#123;%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion;%&#125;&#123;% var len = o.list.length; len = Math.min(len, 3); %&#125;&#123;% if (len &gt;= 1) &#123; %&#125;&lt;div class=\"grid_c1 rec_inner\"&gt;&lt;ul class=\"rec_list\"&gt;&#123;% for(i = 0; i &lt; len; i++)&#123; %&#125;&#123;% var item = o.list[i]; %&#125;&#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125;&lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt;&lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + \\'a\\' + (i &lt; 9 ? \\'0\\' : \\'\\') + (1+i) %&#125;\"&gt;&lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt;&lt;/a&gt;&lt;/li&gt;&#123;% &#125; %&#125;&lt;/ul&gt;&lt;/div&gt;&#123;% &#125; %&#125; ', style: \".rec_list&#123;overflow:hidden;height:100px&#125;.rec_item&#123;overflow:hidden;float:left;width:396px;height:100%&#125;.rec_lk&#123;display:block;height:100%&#125;.rec_img&#123;display:block;margin:auto&#125;.o2_mini .rec_item&#123;width:330px&#125;.csstransitions .rec_img&#123;-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s&#125;.csstransitions .rec_lk:hover .rec_img&#123;opacity:.8&#125;\", time: 1479195351434, version: \"ff78610a0ef9cdbb\"&#125;); 通过上述手段，我们让首屏变得更加精简，从下面的对比中就可以看出 这是过去首页首屏大小 这是新版首页首屏大小 可以看出优化精简之后，新版的首屏的大小减小了非常之多。 首屏轮播第一帧直出一直以来轮播都是靠页面最后加载的JS来进行渲染的，因为轮播图有随机渲染图片的逻辑需要依赖JS，但在一段时间的观察之后发现，如果CDN出现抖动，或者用户的网速较慢，那么首屏轮播这一块位置就会一直空着，给人的体验非常不好 所以在这一版的首页中我们将轮播图第一帧的数据直出在页面上，同时也将第一帧的渲染逻辑也直出在页面上，这样一来，首屏轮播出来得就非常快，减少用户的等待时间。 楼层按需加载与滚动优化首屏直出后，非首屏的内容肯定也不会一次性全部加载，因为像首页这样的页面楼层非常之多，一次性加载全部不仅仅慢，而且对接口来说也是一种损耗，所以我们考虑将楼层按需加载。 在我们新的方案中，已经采用了前端模板+数据的开发模式，所以在开发中我们想用直接书写前端模板的方式来进行开发，然后在本地进行预览，而在项目编译时能将我们的模板编译成独立的文件，方便渲染逻辑进行加载。所幸Athena工具已经支持了这样的功能，在开发中我们以编写前端模板的方式去开发整个页面，随后通过编译工具，在代码编译阶段自动将楼层的模板和样式抽离成一个与组件同名的独立JS文件，通过页面加载逻辑去按需拉取模板文件，再进行渲染。 下面例子揭示了楼层模板生成的过程 直接书写前端模板，编写模板时我们给模板加上标记位 o2-out-tpl1234567891011121314151617181920212223&lt;script type=\"text/template\" class=\"o2template\" o2-out-tpl&gt; &#123;% var i, clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag; var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion; %&#125; &#123;% var len = o.list.length; len = Math.min(len, 3); %&#125; &#123;% if (len &gt;= 1) &#123; %&#125; &lt;div class=\"grid_c1 rec_inner\"&gt; &lt;ul class=\"rec_list\"&gt; &#123;% for(i = 0; i &lt; len; i++)&#123; %&#125; &#123;% var item = o.list[i]; %&#125; &#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125; &lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt; &lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + 'a' + (i &lt; 9 ? '0' : '') + (1+i) %&#125;\"&gt; &lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt; &lt;/a&gt; &lt;/li&gt; &#123;% &#125; %&#125; &lt;/ul&gt; &lt;/div&gt; &#123;% &#125; %&#125;&lt;/script&gt; 在编译时扫描依赖关系，生成模板JS文件依赖组件的关系表1234567891011121314151617181920212223242526272829303132333435\"dependency\": &#123; \"elevator_tpl.js\": [], \"entry_tpl.js\": [ &#123; \"widgetName\": \"spetit\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125; ], \"fbt_tpl.js\": [ &#123; \"widgetName\": \"find\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125;, &#123; \"widgetName\": \"brand\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125;, &#123; \"widgetName\": \"top\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125; ]&#125; 通过关系表去合并处理CSS样式，再和前端模板一起计算出MD5，生成独立的JS文件1jsonCallBack_rec_tpl(&#123;dom:'&#123;%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion;%&#125;&#123;% var len = o.list.length; len = Math.min(len, 3); %&#125;&#123;% if (len &gt;= 1) &#123; %&#125;&lt;div class=\"grid_c1 rec_inner\"&gt;&lt;ul class=\"rec_list\"&gt;&#123;% for(i = 0; i &lt; len; i++)&#123; %&#125;&#123;% var item = o.list[i]; %&#125;&#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125;&lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt;&lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + \\'a\\' + (i &lt; 9 ? \\'0\\' : \\'\\') + (1+i) %&#125;\"&gt;&lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt;&lt;/a&gt;&lt;/li&gt;&#123;% &#125; %&#125;&lt;/ul&gt;&lt;/div&gt;&#123;% &#125; %&#125; ',style:\".rec_list&#123;overflow:hidden;height:100px&#125;.rec_item&#123;overflow:hidden;float:left;width:396px;height:100%&#125;.rec_lk&#123;display:block;height:100%&#125;.rec_img&#123;display:block;margin:auto&#125;.o2_mini .rec_item&#123;width:330px&#125;.csstransitions .rec_img&#123;-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s&#125;.csstransitions .rec_lk:hover .rec_img&#123;opacity:.8&#125;\",time:1479466862559,version:\"ff78610a0ef9cdbb\"&#125;); 同时会在逻辑脚本入口位置自动加入模板的版本号123456789101112&#123; \"elevator_tpl\": \"e4d5dbaa3ecd12d2\", \"entry_tpl\": \"e3150fce4b2b332a\", \"fbt_tpl\": \"18f8bff18188a453\", \"floor_coupon_tpl\": \"1559694cb962e0d6\", \"floor_ract_tpl\": \"13b92d16fb6e2f7a\", \"mod_footer_tpl\": \"49142394d0e7f24e\", \"more_tpl\": \"d300081dd7f13f78\", \"portal_tpl\": \"68fae801a032cf93\", \"rec_tpl\": \"ff78610a0ef9cdbb\", \"seckill_tpl\": \"f11d04fd7eabc0e6\"&#125; 模板文件通过系统发布到CDN后，我们就需要有一套加载逻辑来进行加载。通过监听滚动事件，我们判断让处于浏览器视窗内的楼层进行加载，由于监听了滚动事件，为了让滚动更加流畅，我们必然要对滚动中做的操作进行优化。为了避免滚动操作不断被触发，需要对滚动进行节流处理。我们的原则是尽量避免在滚动的时候进行DOM操作与复杂计算，所以在渲染逻辑初始化的时候，我们就已经收集好了楼层的相关信息，包括楼层高度、楼层的offsetTop等，这样在滚动的时候就不再需要进行任何DOM操作了，让滚动的效率有所提升。而当楼层的数据例如楼层高度发生变化时，则通过消息通知的机制来实时地更新楼层信息即可。 脚本延后加载执行除了楼层是按需加载的，页面中用到的一些脚本文件也是尽量延后加载、执行。Athena工具在代码打包的时候，会对每个独立的文件进行单独处理，同时生成一份静态资源的线上对应表，在编译的最后会将引用的资源替换成配置的线上绝对地址。我们可以使用Seajs提供的require.asyncAPI来进行异步加载资源，这样让资源加载更加合理。 12345// 开发中的代码require.async(__uri('APP_JS_ROOT/header.js'))// 编译后require.async('//misc.360buyimg.com/mtd/pc/index/js/header.js') 同时，还有业务上一些统计上报等逻辑，可以放到 window onload 事件之后再执行，这样可以避免由于类似统计这样的请求占用到页面加载资源，从而降低页面 onload 时间。 模板、数据分离缓存每个楼层都按需加载之后，每次去加载这个楼层是否都要重新去请求这个楼层的模板和数据呢？答案当然是否定的。 目前大部分浏览器已经提供了许多前端缓存的解决方案，而其中兼容性最好，易用性最强的非localStorage莫属。利用localStorage我们可以对模板和数据进行缓存，这样当用户第二次加载的时候就可以不用再去请求网络资源，而可以直接从本地获取了。 但缓存之后如何进行更新呢？我们可以通过进行MD5校验版本来实现。 对数据来说，数据是由后端给出的，我们可以让后端同学将可以缓存的接口数据计算出一个MD5值作为版本号，然后直出在页面上，同时在接口中返回这个版本号，这样当前端去加载是首先判断版本号是否一致，以此来判断是直接读缓存还是从网络请求资源。 而对于模板来说，则可以通过Athena工具，在每次编译的时候自行计算出版本号，写入模板文件和入口JS文件中，这样在模板加载的时候也可以进行比对。 单个模板文件 1234567// https://misc.360buyimg.com/mtd/pc/index/home/rec_tpl.min.jsjsonCallBack_rec_tpl(&#123; dom: '&#123;%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion;%&#125;&#123;% var len = o.list.length; len = Math.min(len, 3); %&#125;&#123;% if (len &gt;= 1) &#123; %&#125;&lt;div class=\"grid_c1 rec_inner\"&gt;&lt;ul class=\"rec_list\"&gt;&#123;% for(i = 0; i &lt; len; i++)&#123; %&#125;&#123;% var item = o.list[i]; %&#125;&#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125;&lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt;&lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + \\'a\\' + (i &lt; 9 ? \\'0\\' : \\'\\') + (1+i) %&#125;\"&gt;&lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt;&lt;/a&gt;&lt;/li&gt;&#123;% &#125; %&#125;&lt;/ul&gt;&lt;/div&gt;&#123;% &#125; %&#125; ', style: \".rec_list&#123;overflow:hidden;height:100px&#125;.rec_item&#123;overflow:hidden;float:left;width:396px;height:100%&#125;.rec_lk&#123;display:block;height:100%&#125;.rec_img&#123;display:block;margin:auto&#125;.o2_mini .rec_item&#123;width:330px&#125;.csstransitions .rec_img&#123;-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s&#125;.csstransitions .rec_lk:hover .rec_img&#123;opacity:.8&#125;\", time: 1479195351434, version: \"ff78610a0ef9cdbb\"&#125;); JS入口文件 1234567891011121314// https://misc.360buyimg.com/mtd/pc/index/home/index_focus.min.jswindow.tplVersion = &#123; \"1212_tpl\": \"ce7dcd7cd0beacb2\", elevator_tpl: \"e4d5dbaa3ecd12d2\", entry_tpl: \"2caa7cd543c322ea\", fbt_tpl: \"18f8bff18188a453\", floor_coupon_tpl: \"b98cf33be84aae98\", floor_ract_tpl: \"13b92d16fb6e2f7a\", mod_footer_tpl: \"072072ffc47778be\", more_tpl: \"25dcb060800c503a\", portal_tpl: \"68fae801a032cf93\", rec_tpl: \"ff78610a0ef9cdbb\", seckill_tpl: \"4fee56c5b073e5e1\"&#125;; 通过上述方式，我们实现了模板、数据的分离缓存，由于楼层类似的关系，页面中的模板大多数是重复，这样子模板缓存起来就能大大提高模板的利用率，当用户第二次访问的时候将不会再产生请求，在加速访问的同时，减少网络带宽消耗，并且如果数据发生更新，用户只需要更新数据即可，大大减少流量消耗。 大量使用WebP格式图片在这次改版中，很多的图片我们都使用了WebP格式来减小图片大小。 WebP格式，是谷歌开发的一种旨在加快图片加载速度的图片格式，图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。但WebP的兼容性不太好，目前基本只有Chrome浏览器可以支持，不过这对我们的首页来说，使用WebP还是会有很大的收益，因为通过我们的统计数据可知，首页Chrome用户已经占到了60%左右。 体验优化探索在努力提升页面性能的同时，还要让页面的用户体验有所提升，这需要我们能站在用户和前端的角度提出合理的优化方案。 高清屏适配方案人类的社会在发展，人类的社会在进步，现如今高清分辨率屏幕的应用已经越来越多，高冷的Mac自不必说，现在许多新型号的Windows电脑也配备了高清分辨率的显示器，所以为了提升这一部分用户的浏览体验，我们需要在高清屏上启用高清素材。 但页面中素材图基本都是运营上传的，如果传两套图对运营来说未免太过麻烦，但如果只传一套高清图，直接展示的话对非高清屏没有必要，会造成流量损耗。这时候京东给力的图片服务就发挥作用了。 图片服务支持按一定规则改变URL来等比缩放图片，例如原图是一张800X340的图片 1//img13.360buyimg.com/cms/jfs/t3412/357/1332248120/113691/f29c2f1e/58244d4dN08b89f9e.jpg!q90.webp 我们可以通过这样设置来得到一样等比缩放400X170的图片 1//img13.360buyimg.com/cms/s400x170_jfs/t3412/357/1332248120/113691/f29c2f1e/58244d4dN08b89f9e.jpg!q90.webp 这样的话，运营同学只需要上传一张高清图片，我们通过判断是否高清屏，来动态改变URL，使用图片服务来得到一张等比缩放的非高清素材，而且CDN会根据图片URL进行缓存，也就是说只要第一次访问过缩放的图片就好，这样性能也不会有什么损耗。 强制webkit内核渲染很多国产浏览器都是双内核，例如360、QQ浏览器等，而它们都提供了强制使用Webkit内核渲染的开启方式，这样可以让用户获得更好的浏览体验。 1&lt;meta name=\"renderer\" content=\"webkit\" /&gt; OpenSearch现在很多网站都能实现在浏览器搜索框内直接调用网站内部搜索的功能，这是通过 OpenSearch 来做到的，而京东之前一直是没有的，这样显然是不合适，而且有一些习惯于使用地址栏搜索的用户不能满足。在这次改版中，我们加上了这一功能，使得用户可以在浏览器地址栏就能直达京东搜索。 使用Icon Font使用Icon Font可以提升设计师的发挥空间，在页面上使用一些特殊字体以提升页面的美观程度，让页面看起来更具有设计感，更加细腻，从而提升用户的浏览体验。 而且Icon Font兼容性非常好，可以让不同浏览器的用户获得一致的浏览体验，并且通过字体压缩工具，压缩后的字体文件也可以非常小，不会有太多的性能损耗。 空闲时间自动加载楼层及图片前文提到，我们使用了按需加载来提升页面性能，但这样带来的问题就是只有当用户滚动楼层到浏览器视窗内，楼层才会开始加载，这样用户滚动得稍微快一点就会出现很多loading动画。 为了减少这种情况的发生，让用户觉得楼层也加载很快，在不影响页面滚动、加载性能的前提下我们在用户操作的空闲时间自动加载剩余的楼层和图片。 将楼层的加载操作放入一个队列中，我们可以在用户停止滚动操作3s后开始自动加载这个队列中的楼层，而当用户开始滚动的时候清空这个加载队列，停止滚动3秒后又重新开始加载。通过这样处理可以合理利用用户浏览的空闲时间来加载页面，让用户感觉页面加载更快。 123456789101112131415161718192021var scrollTimer = null;var isScrolling = false;$(window).bind('scroll.loadFloor', function (e) &#123; isScrolling = true; clearTimeout(autoLoadTimer); clearTimeout(scrollTimer); autoLoadingQueue = []; resourceLoader &amp;&amp; resourceLoader.pause(); scrollTimer = setTimeout(function () &#123; isScrolling = false; if (pageConfig.idleTimeLoad) &#123; autoLoadTimer = setTimeout(autoLoad, 3000); &#125; &#125;, 200);&#125;);function autoLoad () &#123; if (!isScrolling) &#123; runFloorLoadQueue(); &#125;&#125; 页面可用性保障和监控灾备策略对于像京东首页这种大流量的网站，后端接口可能偶尔会出现错误，或者直接挂掉，特别是在双11这种可能会达到流量峰值的时候，但是不能因为接口出错的原因而使得页面显示出现错误。这就需要前端来配合给出一套合理的灾备方案。 通常，我们通过接口缓存、超时、重试来进行灾备处理。目前首页大部分接口、及所有模板请求，在请求成功后都会存入本地缓存，第二次请求，假如缓存没有过期将直接使用缓存，假如缓存过期将会重新请求，而一次正常的请求，都会经过超时或异常重试的逻辑，来保证用户能尽量访问到正常的数据，在正常接口无法获取数据之后又会有兜底接口来保障数据来源，这样的层层保障，很好地保证了页面的完整性。而且，针对所有接口，前端均有数据校验逻辑，每一个后端接口都要经过前端的数据校验，来验证接口的可用性，假如接口数据异常，前端将主动调用兜底接口来替代，这样来保证页面不至于错乱。 综上所述，首页的接口和模板正常请求流程如下 这样一套复杂的流程下，每一个接口、模板请求都是统一的，所以需要对此进行封装，以便调用。首页是通过封装改造$.ajax来实现的，使用$.ajaxPrefilter和$.ajaxTransport方法对每个异步请求进行捕获处理，将接口、模板请求的重试、超时、缓存、兜底调用等封装起来，对调用者透明，使用起来变得非常容易，而不需要关心以上灾备策略的实现。 123456789101112131415161718var ajax = require('load_async');// 本质就是$.ajax方法ajax(&#123; url: '//f.3.cn/index-floor/?argv=aggr', jsonpCallback: 'jsonpCallbakcAggr', // jsonp回调函数名 params: &#123;&#125;, // 参数 needStore: true, // 是否需要缓存 storeSign: '3aad2efsdf', //用户判断缓存是否过期的标记 timeout: 3000, //接口超时 times: 2, // 超时重试次数 backup: '//www.3.cn/bak/aggr', // 兜底接口 dataCheck: function (result) &#123; // 接口数据校验，校验接口返回数据，若为true则走正常逻辑，为false则自动调用兜底逻辑 if (result &amp;&amp; result.code === 0) &#123; return true; &#125; return false; &#125;&#125;); 数据统计驱动改进在这次首页改版项目中我们接入了Athena测速系统用于收集首页各种性能以及用户环境相关的数据，因为有了数据统计，我们才能知道用户端具体的情况信息，有了数据统计，我们才能对页面进行实时监控，有了数据统计，我们才能掌握我们做性能优化的成果，所有的分析都是要基于数据来进行，否则就是在自己在YY了。 目前我们主要收集了，用户网速、操作系统、浏览器分布、分辨率分布等各种信息，同时对于页面加载情况也有一定的监控，如页面测速打点上报、数据接口出现调用兜底接口的情况上报、楼层接口失败导致楼层隐藏的情况上报等。 通过以上数据统计，我们可以灵活地对我们的页面进行优化，同时及时发现问题，避免损失。例如我们通过统计发现用户在网速低于一定值时页面楼层隐藏数增多，这样我们就可以通过设置更长的超时时间来减少这一情况的发生，还有就是假如某时刻开始发现某接口调用兜底请求数暴增，可以判定接口出现问题而及时反馈给后端同学。 更长远的探索新版首页已经上线小一个月了，表现一直还算良好，我们做出的性能以及体验优化也得到了体现，在此基础上，我们思考了更多的可以做的工作，来提升首页的表现。 静态资源预加载首页承载着许多页面的入口，如频道页还有活动页，在双11的时候，首页会有很多直达活动的入口，如果我们能在首页预加载某些重要的活动页面的资源的话，当用户去访问这些活动页面就能更加迅速地打开浏览了。 架构升级jQuery + Seajs或许让人感到老旧且沮丧，我们考虑在首页上渐渐使用一些新的技术，例如去Seajs化，提供更优的打包方式，让页面性能进一步提升。 中间层探索目前首页虽然差不多实现了前后端分离，但是首屏这里前后端依然存在耦合，假如前端可以介入到中间层的开发，那问题就迎刃而解了，接入中间层后，我们还可以将页面部分楼层做服务端渲染，以减少前端渲染的性能损耗，可以在实现前后端分离的基础上，让页面性能更好，还是有一定意义的。","pubDate":"Mon, 26 Dec 2016 12:25:57 GMT","guid":"https://aotu.io/notes/2016/12/26/jd-index-2016-summary/","category":"项目总结"},{"title":"vim给代码行尾加分号的几种方法","link":"https://aotu.io/notes/2016/12/08/vim-4/","description":"给下面的代码每一行行尾加入分号，有几种方法呢？123var foo = 'aotu'var bar = 'is a team'var foobar = foo + bar","pubDate":"Thu, 08 Dec 2016 02:25:35 GMT","guid":"https://aotu.io/notes/2016/12/08/vim-4/","category":"Web开发"},{"title":"正则表达式实践篇","link":"https://aotu.io/notes/2016/12/07/regexp-practice/","description":"简单的练习：题目 与搜索字符串开始处的 3 个数字匹配。 与除 a、b 和 c 以外的任何字符匹配。 &#39;1234567&#39;.match(/\\d{1,3}/g)的结果。 不以“th”开头的单词匹配。 对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字。 匹配一个中文字符。 答案 与搜索字符串开始处的 3 个数字匹配：/^\\d{3}/。 与除 a、b 和 c 以外的任何字符匹配： /[^abc]/。 ‘1234567’.match(/\\d{1,3}/g)，根据贪婪原则，结果是 [&quot;123&quot;, &quot;456&quot;, &quot;7&quot;]。 不以“th”开头的单词匹配：/\\b(?!th)\\w+\\b/ 。 对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字： /^(?=.*\\d).{4,8}$/ 。首先.{4,8} 表示与包含 4-8 个字符的字符串匹配；然后.*表示单个字符（除换行符 \\n 外）零次或多次，且后面跟着一个数字，注意(?=)只匹配一个位置。 匹配一个中文字符：/[\\u4e00-\\u9fa5]/。 当然，可能答案不唯一，不必较真啦~ 主要目的是回忆熟悉一下语法~如果还不了解正则，可以前往正则表达式理论篇 了解哇~ 真正的实践来了要想在复杂性和完整性之间取得平衡，一个重要因素是要了解将要搜索的文本。好的正则表达式： 只匹配期望的文本，排除不期望的文本； 易于控制和理解； 保证效率。 有时候处理各种极端情况会降低成本/收益的比例。所以某些情况下，不完全依赖正则表达式完成全部工作，比如某些字段用子表达式()括起来，让内存记忆下来，然后再用其他程序来验证。 不过本文还是从学习正则的角度出发，全部依赖正则表达式来写的哇~~ 匹配美元正则表达式：/^\\$[0-9]+(\\.[0-9][0-9])?$/。 分为四部分： ^\\$ 以美元符号开头。 [0-9]+ 至少包含一个数字。 (\\.[0-9][0-9])? 由一个点和两位数组成，匹配0次或1次，因为可能是整数或者是小数。 $ 最后的$表示以数字结尾的。 缺点：不能匹配$1,000 匹配24小时制的时间，比如 09:59 小时部分 方法一：分类逻辑为第一个数字(0、1、2)，可以分为三部分：上午 00点到09点（0可选）；白天10到19点；晚上20到23点。 因此有三个多选分支，得到的结果为： 10?[0-9]|1[0-9]|2[0-3] 还可以优化一下，合并前面的两个多选分支，得到： 1[01]?[0-9]|2[0-3] 方法二：分类逻辑为第二个数字，可以分为两部分：[0-3]和[4-9]。为什么这么分？看看下面这个图就知道了，[0-3]多了一行（以2为第一个数字）： 因此有两个多选分支，结果为：1[012]?[0-3]|[01]?[4-9] 分钟部分 分钟数比较简单，第一个数范围在0-5之间，第二个数在0-9之间，因此得到分钟数为: 1[0-5][0-9] 最后的结果： 小时部分用(?:)包起来，起到一个分组的作用，且不保存匹配项；冒号、分钟数拼起来；最后加上一个分界\\b表示单词的开始或结束，得到最终的结果： 123/\\b(?:[01]?[0-9]|2[0-3]):[0-5][0-9]\\b/// 或者/\\b(?:[012]?[0-3]|[01]?[4-9]):[0-5][0-9]\\b/ 验证： 123var reg = /\\b(?:[01]?[0-9]|2[0-3]):[0-5][0-9]\\b/;'现在是09:49点'.match(reg); // [\"09:49\"]'现在是009:490点'.match(reg); // null 其实这个结果不能说完全正确，首先你要明白这个正则用在什么地方，比如是数据验证或者复杂的字符串搜寻替换。 情景一：填写表单中的字符串必须为24小时制的时间，那么可能第一个\\b需要改成^，第二个\\b改成$。 情景二：用于复杂的字符串搜寻替换时，可能也会匹配这样子的字符串如’跑步用时19:50’,明显的，’19:50’表示19分50秒，而不是表示24小时制的时间19点50分。 匹配IP地址IP地址的规则：点号分开的四个字段，每个字段在0-255之间。 第一步： 如果一个字段是一个数或两个数，肯定是在0-255的范围内的；如果三位数，那么以0或者1开头的三位数也是合法的，即000-199。 从上面的陈述中我们就可以得到三个多选分支： 1\\d|\\d\\d|[01]\\d\\d 我们稍微合并一下这三个多选分支，得到： 1[01]?\\d\\d? 第二步： 我们再来看以2开头的三位数： 第二位数小于5的时候，第三位数范围[0-9]都可以；第二位数等于5的时候，第三位数范围[0-5] ，因此得到两个多选分支： 12[0-4]\\d|25[0-5] 第三步： 前两步合并起来，得到一个字段0-255的表示方法： 1[01]?\\d\\d?|2[0-4]\\d|25[0-5] 第四步： 四个字段合并起来，IP地址正则如下： 1/^(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])$/ 点号要转义一下，^和$需要加上，否则可能匹配52123.3.22.993，因为其中的123.3.22.99是符合的。(?:)起到分组的作用，且不保存匹配项。 一些测试结果： 123456var reg = /^(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])$/;'123.11.22.33.44'.match(reg); // null'52123.3.22.993'.match(reg); // null'123.11.22.33'.match(reg); // [\"123.11.22.33\"]'0.0.0.0'.match(reg); // [\"0.0.0.0\"] 虽然0.0.0.0是合法的，但它是非法的IP地址，使用正则的否定顺序环视功能(零宽负向先行断言)，可加上(?!0+.0+.0+.0+$) ： 1234var reg = /^(?!0+.0+.0+.0+$)(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])$/;'123.11.22.33'.match(reg); // [\"123.11.22.33\"]'0.0.0.0'.match(reg); // null 匹配分隔符之内的文本常见的匹配要求 匹配/*和*/之间的css注释。 匹配引文字符串””，且容许其中包含转义的引号\\”。 匹配一个HTML tag，也就是尖括号之内的文本，例如。 匹配思路的步骤 匹配起始分隔符。 匹配正文（即结束分隔符之前的所有文本）。 匹配结束分隔符。 容许引文字符串中出现转义引号大概思路描述：起始分隔符和结束分隔符都是&quot;,且正文中容许出现转义之后的引号\\&quot;。 简单情况分析： 举例：匹配类似 I &quot;start \\&quot;x3\\&quot; end&quot; U 文本的 &quot;start \\&quot;x3\\&quot; end&quot; 引文字符串，注意\\&quot;属于转义引号。 起始分隔符和结束分隔符都是&quot;。 字符不是引号，肯定是正文。即[^&quot;]表示不是引号的其他任意字符。 引号&quot;前面有反斜线\\，且被反斜线\\转义，则也属于正文。例如start\\&quot;引号的前面有一个反斜线，那么这个引号也属于正文。即(?&lt;=\\)”表示匹配一个引号，它的前面有一个\\，注意正则的反斜线也要用\\来转义一下,因为\\是特殊字符。 用非捕获分组(?:)将[^&quot;]|(?&lt;=\\\\)&quot;括起来，给个量词*，表示匹配正文0次或多次。因此可以写出正则表达式： /&quot;(?:[^&quot;]|(?&lt;=\\\\)&quot;)*&quot;/注意：ES7才支持逆序环视(?&lt;=) 验证1：验证正则：/&quot;(?:[^&quot;]|(?&lt;=\\\\)&quot;)*&quot;/ 12345'I \"start \\\"x3\\\" end\" U'.match(/\"(?:[^\"]|(?&lt;=\\\\)\")*\"/);// 结果： [\"\"start \"\"]'I \"start \\\\\"x3\\\\\" end\" U'.match(/\"(?:[^\"]|(?&lt;=\\\\)\")*\"/);// 结果：[\"\"start \\\"x3\\\" end\"\"] 为什么第2个才是对的呢？我们看一下返回的input属性就了解了： 验证2：验证正则：/&quot;(?:[^&quot;]|(?&lt;=\\\\)&quot;)*&quot;/ 1234'I \"start \\\\\"x3\\\\\\\\\" end\" U'.match(/\"(?:[^\"]|(?&lt;=\\\\)\")*\"/);// 结果与期望不符合：[\"\"start \\\"x3\\\\\" end\"\"]// 期望：[\"\"start\\\"x3\\\\\"]// 注意返回的input属性为：\"I \"start \\\"x3\\\\\" end\" U\" 引号”前面有反斜线\\，但是这个反斜线不是转义引号的，那么引号就不应该属于正文，而是属于结束分隔符。什么情况反斜线\\不转义引号呢？这个反斜线\\本身就是被转义的情况。 上面的结果按照预期结果应该返回 [&quot;&quot;start\\&quot;x3\\\\&quot;]，但是现在多了end&quot;。因此验证这个正则表达式不正确。 也就是说，正文中可出现转义的字符，因此得出正则\\\\. ，注意第一个\\表示转义第二个\\,点表示匹配除换行符 \\n 之外的任何单个字符）,例如可以匹配\\+或者\\\\。而且转义的字符已经包含了\\&quot;的情况，因此正则(?&lt;=\\\\)&quot;可以不用写了，且替换成\\\\.。 因此改正后的正则：/&quot;(?:\\\\.|[^&quot;])*&quot;/ 你可能注意到了，我把[^”]和\\.的位置调换一下，后面的验证3会讲到为什么要这么做。 验证3：验证正则：/&quot;(?:\\\\.|[^&quot;])*&quot;/ 和 /&quot;(?:[^&quot;]|\\\\.)*&quot;/ 123456789'I \"start \\\\\"x3\\\\\\\\\" end\" U'.match(/\"(?:\\\\.|[^\"])*\"/);// 结果与期望符合：[\"\"start \\\"x3\\\\\"\"]// input: \"I \"start \\\"x3\\\\\" end\" U\"// [^\"]和\\\\.的位置调换'I \"start \\\\\"x3\\\\\\\\\" end\" U'.match(/\"(?:[^\"]|\\\\.)*\"/);// 结果与期望不符合：[\"\"start \\\"\"]// 期望：[\"\"start\\\"x3\\\\\"]// input: \"I \"start \\\"x3\\\\\" end\" U\" [^&quot;]和\\\\.的位置调换后，结果与期望不符合。那是因为[^&quot;]匹配start \\后，遇到紧接着的&quot;不匹配，交给后面的多选分支\\\\.，也不匹配，又刚好结束分隔符是&quot;,导致匹配成功，结束匹配。 因此两个正则之间 正确的正则是 /&quot;(?:\\\\.|[^&quot;])*&quot;/ 验证4：验证：/&quot;(?:\\\\.|[^&quot;])*&quot;/ 1234'I \"start \\\\\"x3\\\\\" end U'.match(/\"(?:\\\\.|[^\"])*\"/);// 结果与期望不符合：[\"\"start \\\"x3\\\"\"]// 注意end后面少了\",期望结果是null，不匹配// input: \"I \"start \\\"x3\\\" end U\" 上面的字符串 &quot;start\\&quot;x3\\&quot; 其实是没有结束分隔符的，但是还是匹配了。那是因为正则[^&quot;]和\\\\. 一起作用,导致匹配到了文本U末尾，后续想找结束分隔符的时候，结果却找不到，所以只能回溯文本去找结束分隔符，最后找到了 x3\\后面的引号，匹配成功，结束匹配。 回溯会导致不期望的结果，由于是卡在多选分支上出错的，因此猜测多选分支|匹配内容出现重叠。 你想想，如果符合正文的反斜线，不是以[^&quot;]方式匹配,而是以\\\\.的方式匹配，那就不会把好好的\\&quot;拆开来匹配了。 综上所述，一定要让反斜线是以\\\\.的方式匹配，字符串里的反斜杆不能以[^&quot;]方式匹配。因此将[^&quot;]改成[^\\\\&quot;]。这样子就可以确保正确识别正文特殊的\\&quot;和结束分隔符&quot;了。 注意：很多字符在[]都会失去本来的意义，但是反斜杠字符 \\ 仍为转义字符。若要匹配反斜杠字符，请使用两个反斜杠 \\\\。 改正的正则：/&quot;(?:\\\\.|[^\\\\&quot;])*&quot;/ 验证5验证：/&quot;(?:\\\\.|[^\\\\&quot;])*&quot;/ 12345678'I \"start \\\\\"x3\\\\\" end U'.match(/\"(?:\\\\.|[^\\\\\"])*\"/);// 结果与期望符合：null// input: \"I \"start \\\"x3\\\" end\" U\"'I \"start \\\\\"x3\\\\\" end\" U'.match(/\"(?:\\\\.|[^\\\\\"])*\"/);// 结果与期望符合：[\"\"start \\\"x3\\\" end\"\"]// input: \"I \"start \\\"x3\\\" end\" U\" 为了优化，我们可以把[^\\\\&quot;]放在前面，因为普通字符的匹配可能性更大。注意：优化正则提高效率最需要考虑的问题：改动是否会影响匹配。只有在排序与匹配成功无关时才不会影响准确性，才能重新安排多选分支的顺序。 优化后的正则：/&quot;(?:[^\\\\&quot;]|\\\\.)*&quot;/ HTML Tag经历了容许引文字符串中出现转义引号的例子分析，瞬间觉得这个容易了许多。 描述与要求：匹配类似&lt;input name=123 value=&quot;&gt;&quot; &gt;的HTML标签，起始分隔符是&lt;，结束分隔符是&gt;，且HTML 标签属性值中可以出现&gt;。 起始分隔符和结束分隔符都是明确的，我们来分类一下正文。 双引号引用文本 单引号引用文本 除了&gt;和引号之外的任意字符 可能你会当心单双引号引用文本，会像“容许引文字符串中出现转义引号”那么复杂。幸好是HTML Tag的属性值中不允许出现转义引号，因为平常的转义符号\\变成了普通字符。 根据三种情况，分别写出三个正则： &quot;[^&quot;]*&quot; &#39;[^&#39;]*&#39; [^&#39;&quot;&gt;] 好了，用多选分支连起来&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;]，再用非捕获分组(?:)将多选分支括起来，如(?:&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])，用*表示匹配任意次，最后前后加上开始结束分隔符，搞定： /&lt;(?:&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;/ 验证： 12'&lt;input name=123 value=\"&gt;\" &gt;'.match(/&lt;(?:\"[^\"]*\"|'[^']*'|[^'\"&gt;])*&gt;/)// 结果： [\"&lt;input name=123 value=\"&gt;\" &gt;\"] 体会：看到没有，几乎每个正则都包含多选分支，只要你懂得将数据分类，离成功就不远了。哈哈哈哈哈。 参考《精通正则表达式》http://imweb.io/topic/56e804ef1a5f05dc50643106","pubDate":"Wed, 07 Dec 2016 02:34:01 GMT","guid":"https://aotu.io/notes/2016/12/07/regexp-practice/","category":"Web开发"},{"title":"源码赏析 - 1K的Firewatch游戏","link":"https://aotu.io/notes/2016/12/04/firewatcher-appreciation/","description":"前言讲真，做前端越久，我们就越容易被思维所束缚。比如，应该没几个人会相信用1K代码能够写出一个游戏，而且还是3d的游戏。 在看这段代码之前我们不得不提到一个一年一度的比赛：js1k。每年，主办方会提出一个比赛主题，参赛者们必须围绕这个主题，用1024个字节以内的JS代码做一个参赛作品。比赛的要求有以下几个： Create a fancy pancy JavaScript demo (用JS做出一个华丽的demo) Submissions may be up to 1024 bytes (最多1024字节) Externals are strictly forbidden (禁止引用外部资源) Must work current generation browsers (必须能在现代浏览器中运行) Minification and hacks allowed (允许代码压缩或者hack) 另外，作为基础，demo运行的环境中内置了一部分变量供调用： window.a 是一个canvas元素 window.b 是document.body window.c 是a元素对应的2D/3D上下文 window.d 是document对象 是不是还挺贴心？只需要用一个字母就可以调用原本一长串代码才能拿到的对象喔。 除了这些，比赛还有一些小规则，可以查看比赛的 规则页 ，里面有详细描述，这里就不再多说。 今年比赛的主题是 Let’s get eleMental!，我们今天要看的 Firewatch 就是其中第三位的作品（第一名作品是 Romanesco 2.0 3D分形展示，有强烈的不明觉厉感，建议前往围观；第二名 Voxeling 是一个3D像素Demo）。 Demo介绍游戏通过键盘上下左右+空格键操作。在开始游戏后，面前会有一颗烟花炸开。紧接着烟花下的树开始着火。玩家的任务就是按下空格，用水枪将火扑灭。在一定时间后，树上的火还会点燃周围的树。如果不慎走神，很有可能就救不回这片森林了喔。 源码解析粗略地讲，这份源码总共就分为两个部分： 创建对象 绑定用户交互，进行事件循环 创建对象下面是创建对象部分的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// add treesfor (entities = [playerA = 256]; s = playerX = playerZ = playerA--;) for ( // create trunk entities.push(&#123; c: [i = 12, 60, 30], x: X = Math.sqrt(playerA) * 12 * Math.cos(playerA) + Math.random() * 12, h: 1, y: Y = Math.random() * 3 - 1, z: Z = Math.sqrt(playerA) * 12 * Math.sin(playerA) + Math.random() * 12, s: 2, S: Y * 2 + 16 &#125;); i--; // create leaf entities.push(&#123; c: [150, 60, i * 2], x: X + f * Math.cos(e = Math.random() * 7), z: Z + f * Math.sin(e), h: 860, y: Y - i / 2 + 10, s: 8 &#125;) ) // create fallen fruit f = Math.random() * 7, i % 2 || entities.push(&#123; c: [50, 60, i * 2], x: X + f * Math.cos(e = Math.random() * 7), z: Z + f * Math.sin(e), h: 860, y: -8, s: 1 &#125;);// burn a leaf (doubles as object for active keys)entities[30].p = burn = function (e, f) &#123; // update fire e.h--; e.c = [Math.random() * 60, 100, 0], e.s = Math.random() * 5 + 6, // create smoke / fireworks s % 16 || entities.push(&#123; c: [0, 0, e.w ? -30 : 10], x: e.x + Math.random() * 6, y: e.y, z: e.z, h: 90, v: 60, p: s ? function (e, f) &#123; e.h--; e.y += .5 &#125; : function (e, f) &#123; e.h--; e.c = [Math.random() * 60, 100, 0], e.h &lt; 12 ? e.s += 3 : e.y += 3 &#125;, s: 4 &#125;); // spread fire entities.some(function (f) &#123; return(s % 300 || f.s == 8 &amp;&amp; Math.abs(e.x - f.x) + Math.abs(e.z - f.z) &lt; 40 &amp;&amp; Math.random() * 50 &lt; 1 &amp;&amp; (f.p = burn)) &#125;); e.w = 0&#125;; 为了减少代码占用的空间，作者大量使用了单字母的变量名与属性名，比如entities.c，entities.x等等，代码可读性非常差。 浏览一遍，我们是根本看不出上面这些变量是什么含义了。 但是，我们能够确定的是，这段代码初始化了playerA，playerX，playerZ变量，然后把所有的对象设定好属性后都存入了entities数组中，包括树干，树底下的水果，还有树干等等。没办法，只能先跳过这部分了。 用户交互这是代码中主管用户交互的代码： 123onkeydown = onkeyup = function (e, f) &#123; burn[e.keyCode - 32] = e.type[5]&#125;; 蛤？就这么短？ … 真是这么短。 上面这段代码，看着更像是定义了onkeydown跟onkeyup俩函数，后面理应还有类似于addEventListener之类的语句将这个函数绑定给某个元素某个事件的代码。因为身为前端，我们早已习惯绑定事件的那几种套路： 1234DomEl.addEventListener(eventname, callback); // webkitDomEl.attachEvent(eventname, callback); // IE$.bind(eventname, callback); // jQ// ... 可是任凭老司机怎么 Ctrl+f 搜索代码，也并没有找到所谓的绑定事件的语句。 事实上，作者在定义这两个函数的时候，并没有使用var关键字。意味着，这后面定义的变量，是直接挂在window下的。那么凭空定义的这两个函数，就分别会变成 window.onkeydown 和 window.onkeyup 。没错，这就是我们极度不推崇的绑定回调的方式了。 回调函数的内容，是在用户按下按键的时候将burn中下标为 keyCode - 32 的属性设定为 keydown 或者 keyup 的第六个字母，也就是 w 或者 undefined 。这个做法十分精妙，下面举例说明。 假设我们按下了空格键（keyCode=32），执行 onkeydown 函数，burn[0] = &#39;w&#39;；而放手的时候，则执行 onkeyup 函数， burn[0] = undefined 。这样一来，在事件循环里面只需要判断burn[0]是true还是false，就可以知道空格键按下了没有。同理，burn[5]，burn[6]，burn[7]，burn[8]分别代表了左，上，右，下键的状态。 可是，印象中burn是个函数呀，entities[30].p = burn = function (e, f) {...}，怎么就用来表示按键状态了呢？目的只能有一个，省下一个声明变量的语句。 为了省下多几个字符，程序员真是什么事都做得出来啊… 事件循环终于到了事件循环部分了。这部分代码占了源码大概一半的篇幅。折叠后，代码结构大概是这样的： 结构大概清晰了：首先是玩家的移动，接着是水枪的处理，紧接着是背景天空森林地板的渲染。 每个事件循环一开始，先是移动玩家。1234// move playerplayerA += (!!burn[7] - !!burn[5]) / 20,playerX += (e = !!burn[6] - !!burn[8]) * Math.sin(playerA),playerZ += e * Math.cos(playerA), 理解了用户交互部分的内容，这里就很好理解了。burn[5]与burn[7]分管左右两键，那么playerA很明显就是用户的朝向。而burn[6]与burn[8]分管前后，在经过换算后，我们很快也就能知道playerX与playerZ分别是玩家在x-z平面上的坐标。别忘了这游戏可是3D的，所以并不用x-y坐标系。 接下来是水枪的代码： 1234567891011121314151617181920// discharge waterburn[0] &amp;&amp; entities.push(&#123; c: [200, 60, -5 * Math.sin(s)], x: playerX + 12 * Math.cos(playerA), z: playerZ - 12 * Math.sin(playerA), e: playerA - .5, s: 2, h: 20, p: function (e, f) &#123; e.h--; e.x += 2 * Math.sin(e.e), e.z += 2 * Math.cos(e.e), e.y = 5 - (e.h / 2 - 5) * (e.h / 2 - 5) / 2, entities.some(function (f) &#123; f.p == burn &amp;&amp; Math.abs(e.x - f.x) + Math.abs(e.z - f.z) &lt; e.s / 2 + f.s / 2 &amp;&amp; ( f.h -= f.w = 9 ) &#125;); &#125;&#125;); 只要空格被按下，就会有新的对象被插入entities数组中。不过既然是水枪的代码，我们很容易可以想到，这里插进去的对象正是水流。 水流浇到火上是可以灭火的，所以下面这段带有一堆abs的代码，十有八九是用来判断水流跟火焰的位置关系的。 12345entities.some(function (f) &#123; f.p == burn &amp;&amp; Math.abs(e.x - f.x) + Math.abs(e.z - f.z) &lt; e.s / 2 + f.s / 2 &amp;&amp; ( f.h -= f.w = 9 )&#125;); 后面可以证明我们的猜测并没有错。另外，这段代码最后的&amp;&amp;符号后面的代码，就是灭火的处理函数了。 遍历数组，我们一般是用forEach，而作者在这个例子中全都是用some来做的。我猜作者并没有别的用意，纯粹是因为长度的原因。所以我觉得这里使用map应该更好。 接下来是一些零散的处理。 1234567// prepare canvasc.translate(90, (a.height += 0) / 2 - 120 | 0);// update entitiesentities.some(function (f) &#123; f.p &amp;&amp; f.p(f)&#125;); 首先是平移了画布，其次是遍历对象数组，执行对象的p函数。这样一来就很清晰了。对象的属性p，就是在每个事件循环中处理对象的函数。 1234// draw skyfor (i = 30; i--;) c.fillStyle = 'hsla(' + [160, 60 + '%', 50 + i + '%', 1], c.fillRect(0, i * 4, 320, 4); 接下来，作者巧妙地用循环 + hsla渲染了一个带渐变色的天空。 1234// remove entities no longer neededentities = entities.filter(function (e, f) &#123; return(e.h &gt; 0)&#125;); 这段代码过滤掉了对象数组中h属性不大于0的对象。 回想一下，我们前面看到的每种对象的p函数，都带着h–，而p函数在每个事件循环都会执行。那么这个h属性表示的就是对象的寿命了。这个事件循环的间隔是33ms，也就是30h相当于1秒。 1234567891011121314151617// draw background forestfor (i = 30; i--;) c.fillStyle = 'hsla(' + [160, 60 + '%', 10 + i + '%', 1], c.fillRect(0, 220 - i * 4, 320, 4);// sort entities by distance from the screenentities.some(function (f) &#123; f.Z = (f.x - playerX) * Math.sin(playerA) + (f.z - playerZ) * Math.cos(playerA)&#125;);entities.sort(function (e, f) &#123; return(f.Z - e.Z)&#125;);// draw groundfor (i = 30; i--;) c.fillStyle = 'hsla(' + [10 + 60, 60 + '%', 50 + i + '%', 1], c.fillRect(0, 236 - i * 4, 320, 4); 接下来的这部分，前面的画背景与后面的画地板还是跟前面一样的套路，分别使用循环来绘制带渐变色的森林与地板。可是中间这段是什么鬼？ 根据注释说明，这个部分是将Z属性设置为对象到屏幕的距离，随后做了一次从近到远排序。 至于对象到屏幕的距离如何计算，这里直接画图说明，就不再赘述。 12345678910111213// draw entitiesentities.some(function (f) &#123; !f.v &amp;&amp; f.Z &gt; 160 || f.Z &lt; 8 || Math.abs(e = (f.x - playerX) * Math.cos(playerA) * 160 / f.Z - (f.z - playerZ) * Math.sin(playerA) * 160 / f.Z) &lt; 160 &amp;&amp; ( c.fillStyle = 'hsla(' + [f.c[0], f.c[1] + '%', f.Z / 6 - f.c[2] + 46 + '%', f.S ? 1 : .8], c.fillRect( 160 + e - f.s * 160 / f.Z / 2, 120 - f.y * 160 / f.Z - (f.S || f.s) * 160 / f.Z / 2, f.s * 160 / f.Z, (f.S || f.s) * 160 / f.Z ) )&#125;); 接下来的这段代码就是这个游戏的灵魂所在了。 这是一个遍历entities数组的操作。以 || 符号分割，这个操作可以分为三个部分： !f.v &amp;&amp; f.Z &gt; 160 f.Z &lt; 8 Math.abs(...) &lt; 160 &amp;&amp; (...) 语句1跟2只要有一个成立，语句3就不会被执行。语句1跟2也很好理解，主要是判断对象跟屏幕之间的距离是不是处在(8, 160)的区间内，如果不是就直接跳过该对象。 这里有一个例外情况，在距离大于160的情况下，如果对象带有v属性则还是可以继续后面的判断的。纵观整个代码，带有v属性的只有前面提到的烟雾以及烟花。这就说明烟雾与烟花就算是在160距离开外，依然是可以看到的，事实上也的确如此。 语句3被 &amp;&amp; 符号分割为了两部分： Math.abs(e = (f.x - playerX) * Math.cos(playerA) * 160 / f.Z - (f.z - playerZ) * Math.sin(playerA) * 160 / f.Z) &lt; 160 (c.fillStyle=&#39;...&#39;,c.fillRect(...)) 语句1中的比较，转换为代数式，经过简单的代数变换后，可以变为： dx*cos(α) - dz*sin(α) &lt; f.Z 结合刚刚的图，这个语句意义就是指，线段a需要小于f.Z。而从图上我们可以知道，线段a就是对象投影在屏幕上后与玩家的距离。这样一来，视角90°以外的对象就不会被渲染了。 语句2就是渲染对象的语句了。看到这里的fillStyle函数我们才明白，前面所定义的f.c属性，其实就是定义了对象颜色的hsl值。另外，从fillRect函数的传参情况来看，也很容易看出f.y指的就是对象的y坐标，f.s表示对象的宽高，而f.S则是在绘制树干的时候作为对象的高度来使用。 再回首现在我们对这段代码有大概的理解了，是时候回头看一看了。 首先是创建对象的部分，此处开了两重循环，种下了256课树，每棵树分别有一根树干，12个对象组成的叶子，另外地上有6个果实。 接下来，第30棵树被恶意纵了火（将f.p设置为burn函数），第一棵着火的树还会发出一个烟花作为信号。而由于每一帧最后都有s--语句，这个s被作为一个计数器，让着火的树每16帧发出一个烟圈。 过后，就是熟悉的与用户交互的环节了。这部分已经十分清晰，就不再赘述。 写在最后这段代码虽然短，却是麻雀虽小五脏俱全。实现了游戏的基本功能不说，有一些小细节也是让我大吃一惊。比如树着火时冒出的烟，在普通情况下是深灰色的，而在被水枪浇到的时候，会变成浅灰色；又比如寿命的设定，使树叶在着火之后一段时间会被烧完。 在编程思想上，作者也是很有见地。使用entities数组存储所有对象的信息，给每种对象一个变换函数，这本身就有粒子的思想在其中。此外，setInterval的使用，则是再正常不过的事件循环机制的实现。 编程手法就不用多说了。比如各种利用some函数代替forEach来省字数，又或者是利用burn[e.keyCode - 32] = e.type[5]来判断按键的状态……作者是老司机，这一点是没跑了。 这段代码构思巧妙，思路行云流水…类似的溢美之词说再多也没用。更关键的是，我们干前端这一行的，绝对不只是jQ，选择器，或者node小工具。偶尔看一看别人的代码，还是能够学到很多意想不到的知识的。 参考资料 js1k官网 http://js1k.com js1k规则页 http://js1k.com/2016-elemental/rules Romanesco 2.0 http://js1k.com/2016-elemental/demo/2552 Voxeling http://js1k.com/2016-elemental/demo/2497 Firewatch http://js1k.com/2016-elemental/demo/2512 Firewatch 源码 http://js1k.com/2016-elemental/details/2512","pubDate":"Sun, 04 Dec 2016 15:33:00 GMT","guid":"https://aotu.io/notes/2016/12/04/firewatcher-appreciation/","category":"js1k 游戏 3D"}]}